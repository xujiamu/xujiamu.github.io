<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>学习JavaScript数据结构与算法 | Mu的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习JavaScript数据结构与算法 第一章 JavaScript简介服务器环境搭建Chrome - 安装插件 `WebServer for Chrome` - 打开该插件可以点击CHOOSE FOLDER来选择需要在哪个文件夹中开启服务器 - 然后就能通过设定的URL（默认是http://127.0.0.1:8887）来进行访问">
<meta property="og:type" content="article">
<meta property="og:title" content="学习JavaScript数据结构与算法">
<meta property="og:url" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/index.html">
<meta property="og:site_name" content="Mu的博客">
<meta property="og:description" content="学习JavaScript数据结构与算法 第一章 JavaScript简介服务器环境搭建Chrome - 安装插件 `WebServer for Chrome` - 打开该插件可以点击CHOOSE FOLDER来选择需要在哪个文件夹中开启服务器 - 然后就能通过设定的URL（默认是http://127.0.0.1:8887）来进行访问">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/01.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/02.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/03.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/数据结构01.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/数据结构02.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/数据结构03.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/数据结构04.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/循环链表.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/双向循环链表.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/并集.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/交集.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/差集.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/子集.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/散列表01.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/散列表02.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/散列表03.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/线性探测.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/软删除.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/移动元素.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/谷歌调用栈.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/调用栈.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/谷歌栈溢出.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/二叉搜索树.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/节点的高度.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/平衡因子.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树01.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树02.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树03.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树04.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树05.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树06.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树07.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树08.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树09.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树10.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/红黑树11.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/二叉堆.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/图1.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/图2.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/有向图.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/加权图.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/邻接矩阵.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/邻接表.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/关联矩阵.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/广度优先搜索.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/深度优先.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/深度优先具体流程.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/深度优先2.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/有向无环图.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/拓扑排序.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/最短路径.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/mst.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/冒泡排序.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/选择排序.gif">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/归并排序.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/希尔排序.png">
<meta property="og:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/顺序搜索.png">
<meta property="og:updated_time" content="2022-03-27T08:11:50.497Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习JavaScript数据结构与算法">
<meta name="twitter:description" content="学习JavaScript数据结构与算法 第一章 JavaScript简介服务器环境搭建Chrome - 安装插件 `WebServer for Chrome` - 打开该插件可以点击CHOOSE FOLDER来选择需要在哪个文件夹中开启服务器 - 然后就能通过设定的URL（默认是http://127.0.0.1:8887）来进行访问">
<meta name="twitter:image" content="http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/01.png">
  
    <link rel="alternative" href="/atom.xml" title="Mu的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/img/favicon.ico">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?a30844fa2bcbce0a9e001fe06cefeddf";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


</head>
</html>
<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="" class="profilepic">
			<img src="/assets/img/avatar.png" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="">Mu</a></h1>
		</hgroup>
		
		<p class="header-subtitle">鱼跃此时海，花开彼岸天</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/xujiamu" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="/" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="psn" target="_blank" href="/dist/index.html" title="psn"><i class="icon-psn"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/img/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">Mu</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>鱼跃此时海，花开彼岸天<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/xujiamu" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="/" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="psn" target="_blank" href="/dist/index.html" title="psn"><i class="icon-psn"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 100%"><a href="/">主页</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-学习JavaScript数据结构与算法" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      学习JavaScript数据结构与算法
    </h1>
  

        
        <a href="/2021/11/04/学习JavaScript数据结构与算法/" class="archive-article-date">
  	<time datetime="2021-11-04T14:52:01.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-04</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>学习JavaScript数据结构与算法</p>
<h2 id="第一章-JavaScript简介"><a href="#第一章-JavaScript简介" class="headerlink" title="第一章 JavaScript简介"></a>第一章 JavaScript简介</h2><h3 id="服务器环境搭建"><a href="#服务器环境搭建" class="headerlink" title="服务器环境搭建"></a>服务器环境搭建</h3><p><strong>Chrome</strong></p>
<pre><code>- 安装插件 `WebServer for Chrome`
- 打开该插件可以点击CHOOSE FOLDER来选择需要在哪个文件夹中开启服务器
- 然后就能通过设定的URL（默认是http://127.0.0.1:8887）来进行访问</code></pre><a id="more"></a>

<p><strong>Node.js</strong></p>
<ul>
<li>安装http-server <ul>
<li><code>npm  install http-server -g</code></li>
<li>如果是linux系统 <code>sudo npm  install http-server -g</code></li>
</ul>
</li>
<li>在代码文件夹下的终端执行<ul>
<li><code>http-server</code>启动服务器</li>
<li>服务启动后会返回访问地址，之后通过指定端口进行访问即可</li>
</ul>
</li>
</ul>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(test)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为此处赋值的是全局变量，所以当此函数执行后，外部test2被重新赋值</span></span><br><span class="line">    test2 = <span class="number">1</span>   </span><br><span class="line">    <span class="built_in">console</span>.log(test2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test) <span class="comment">// 0</span></span><br><span class="line">fun1()  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(test) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(test2) <span class="comment">// 0</span></span><br><span class="line">fun2() <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(test2) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><strong>逻辑运算符</strong>（逻辑上的真假判断）</p>
<ul>
<li>&amp;&amp; 与 </li>
<li>|| 或</li>
<li>！ 非</li>
</ul>
<p><strong>位运算符</strong>（二进制位运算）</p>
<ul>
<li>在了解位运算之前，首先要了解原反补码的概念</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>将一个十进制整数转成二进制，就是原码</td>
<td>正数的反码等于原码，负数的反码是除符号位以外，全部取反</td>
<td>正数的补码等于原码，负数的补码等于其反码加1</td>
</tr>
<tr>
<td>正数(第一位符号位是0）</td>
<td>如： 5  -&gt; 0000 0101</td>
<td>如：  5 -&gt; 0000 0101</td>
<td>如：  5 -&gt; 0000 0101</td>
</tr>
<tr>
<td>负数(第一位符号位是0）</td>
<td>如：-3 -&gt; 1000 0011</td>
<td>如：   -3 -&gt; 1111 1100</td>
<td>如：  -3-&gt; 1111 1101</td>
</tr>
</tbody></table>
<ul>
<li><p>在计算机中内存中，数字由补码的形式保存，所以下面的位运算符，都需要现将两边的数字转换成补码，之后再计算，注意：计算结果也是补码，如果想要得到10进制数 还要将其转为原码</p>
</li>
<li><p>&amp; 与</p>
<ul>
<li>如 5 &amp; -3</li>
<li>转为二进制补码 0000 0101  1111 1101  取<strong>公共部分</strong>，</li>
<li>得到补码0000 0101 转为原码0000 0101 转为 10进制， 结果 是5</li>
</ul>
</li>
<li><p>| 或</p>
<ul>
<li>如 5 | -3</li>
<li>则 转为二进制补码 0000 0101  1111 1101  取所有<strong>为1的部分</strong>，</li>
<li>得到补码 1111 1101 转为原码 1000 0011, 转为10进制， 结果 -3</li>
</ul>
</li>
<li><p>～ 非</p>
<ul>
<li>作用是将每位二进制取反</li>
<li>如 ~5</li>
<li>补码 0000 0101 取反 1111 1010 转为原码 1000 0110 ,转为10进制，结果 -6</li>
<li>如 -3</li>
<li>补码 1111 1101  取反 0000 0010 转为原码 0000 0010 转为10进制 ，结果 2</li>
<li>注意： ～非，口诀 <ul>
<li>所有正整数的按位取反是其本身+1的负数</li>
<li>所有负整数的按位取反是其本身+1的绝对值</li>
<li>零的按位取反是 -1（0在数学界既不是正数也不是负数） </li>
</ul>
</li>
</ul>
</li>
<li><p>^ 异或</p>
<ul>
<li>取只有一位是1的部分</li>
<li>如 5 ^ -3</li>
<li>转为补码 0000 0101 和 1111 1101 ，得到补码，1111 1000</li>
<li>转为原码 1000 1000, 转为10进制，结果是  -8</li>
</ul>
</li>
<li><p><code>&lt;&lt;</code> 左移 </p>
<ul>
<li>除符号位外整体向左移动指定位数，多余高位舍弃， 新增低位 不管正负数都补0<ul>
<li>在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次，左移n位就相当于乘以2的n次方。</li>
</ul>
</li>
<li>如 5 &lt;&lt; 2 ， 5 乘2的2次方 5 * 4 = 20</li>
<li>补码 0000 0101 移动2位 0001 0100  转为原码  0001 0100 转为 10进制 20</li>
<li>如 -5 &lt;&lt; 2</li>
<li>补码 1111 1011 移动2位 1110 1100 转为原码 1001 0100 转为 10进制 -20</li>
</ul>
</li>
<li><p><code>&gt;&gt;</code> 右移</p>
<ul>
<li><p>除符号位外整体向右移动指定位数，多余低位舍弃， 新增高位正数补0，负数补1</p>
<ul>
<li><p>右移一位相当于除2，右移n位相当于除以2的n次方。</p>
<p>5 /(2^2)=1, 若为小数，则向下取整即可</p>
</li>
</ul>
</li>
<li><p>如 5 &gt;&gt; 2</p>
</li>
<li><p>补码 0000 0101 移动2位 0000 0001 转为原码 0000 0001 转为 10进制 1</p>
</li>
<li><p>如 -5 &gt;&gt; 2,   -5/(2^2)= - 2向下取整</p>
</li>
<li><p>补码 1111 1011 移动2位 1111 1110 转为原码 1000 0010 转为 10进制 -2</p>
</li>
</ul>
</li>
</ul>
<p><strong>关于typeof</strong> </p>
<ul>
<li><p>返回一个字符串，该字符串是变量或表达式的类型</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">37</span> === <span class="string">'number'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">''</span> === <span class="string">'string'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">'boolean'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">'symbol'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">'undefined'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; === <span class="string">'object'</span>;</span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] === <span class="string">'object'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() === <span class="string">'object'</span>;</span><br><span class="line"><span class="keyword">typeof</span> /regex/ === <span class="string">'object'</span>; <span class="comment">// 正则表达式</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="string">'object'</span>;  <span class="comment">// 构造函数实例</span></span><br><span class="line"><span class="comment">// 特殊情况</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据标准，在JavaScript中有两种数据类型。</p>
<ul>
<li>原始数据类型：Null、Undefined、String、Number、Boolean、Symbol、BigInt。</li>
<li>派生数据类型/对象：JavaScript对象，包括函数、数组和正则表达式。</li>
</ul>
</li>
</ul>
<p><strong>关于delete</strong> </p>
<ul>
<li><p>用于删除对象中的属性</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">delete</span> test.a</span><br><span class="line"><span class="built_in">console</span>.log(test) <span class="comment">// &#123;b: 2&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="真值和假值"><a href="#真值和假值" class="headerlink" title="真值和假值"></a>真值和假值</h4><table>
<thead>
<tr>
<th>数值类型</th>
<th>转换成布尔值</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>false</td>
</tr>
<tr>
<td>number</td>
<td>+0, -0 ,NaN 是 false , 其他是 true</td>
</tr>
<tr>
<td>string</td>
<td>‘’ 是 false ,其他是 true</td>
</tr>
<tr>
<td>object</td>
<td>true</td>
</tr>
</tbody></table>
<h4 id="相等运算符-（-和-）"><a href="#相等运算符-（-和-）" class="headerlink" title="相等运算符 （== 和 === ）"></a>相等运算符 （== 和 === ）</h4><ul>
<li>关于这两个相等运算符的使用区分，可参见《你不知道的JavaScript（中卷）》 第4章 强制类型转换</li>
</ul>
<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>JavaScript的控制结构与C和Java里的类似。条件语句支持if…else和switch。循环支持while、do…while和for。</p>
<p><code>switch</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> month = <span class="number">5</span></span><br><span class="line"><span class="keyword">switch</span>(month) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'1月'</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'2月'</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'不是1月和2月'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do...while</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 输出 0 - 9</span></span><br><span class="line">    i++</span><br><span class="line">&#125; <span class="keyword">while</span> ( i &lt; <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>略</p>
<h3 id="JavaScript面向对象编程"><a href="#JavaScript面向对象编程" class="headerlink" title="JavaScript面向对象编程"></a>JavaScript面向对象编程</h3><ul>
<li>创建一个对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 方式</span></span><br><span class="line"><span class="keyword">let</span> obj  = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="comment">// 字面量方式</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在面向对象编程（OOP）中，对象是类的实例<ul>
<li>使用构造函数创建类</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在原型中声明方法，从而避免在构造函数中声明导致实例化时多次创建方法</span></span><br><span class="line">person.prototype.sayname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><ul>
<li>vscode 使用　Debugger for Chrome　插件进行调试</li>
</ul>
<h2 id="第二章-ECMAScript和TypeScript概述"><a href="#第二章-ECMAScript和TypeScript概述" class="headerlink" title="第二章 ECMAScript和TypeScript概述"></a>第二章 ECMAScript和TypeScript概述</h2><h3 id="ECMAScript还是JavaScript"><a href="#ECMAScript还是JavaScript" class="headerlink" title="ECMAScript还是JavaScript"></a>ECMAScript还是JavaScript</h3><p>ECMA是一个将JavaScript标准化的组织，该标准被称作ECMAScript</p>
<h3 id="ES6、ES2015、ES7、ES2016、ES8、ES2017和ES-Next"><a href="#ES6、ES2015、ES7、ES2016、ES8、ES2017和ES-Next" class="headerlink" title="ES6、ES2015、ES7、ES2016、ES8、ES2017和ES.Next"></a>ES6、ES2015、ES7、ES2016、ES8、ES2017和ES.Next</h3><ul>
<li>ECMAScript 5（即ES5，其中的ES是ECMAScript的简称），2009年12月发布</li>
<li>ECMAScript 2015（ES2015）在2015年6月标准化，ES6</li>
<li>2016年6月，ECMAScript第七版被标准化，称为ECMAScript2016或ES2016（ES7）</li>
<li>2017年6月，ECMAScript第八版被标准化。称它为ECMAScript 2017或ES2017（ES8）</li>
<li>ES.Next 用来指代下一个版本的ECMAScript。</li>
</ul>
<p><strong><a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">查看各个浏览器中哪些特性可用</a></strong></p>
<ul>
<li>在谷歌Chrome浏览器中，你可以访问<em>chrome://flags/#enable-javascript-harmony</em>，开启Experimental JavaScript标志，启用新功能</li>
</ul>
<h3 id="使用Babel-js"><a href="#使用Babel-js" class="headerlink" title="使用Babel.js"></a>使用Babel.js</h3><ul>
<li>Babel是一个JavaScript转译器，也称为源代码编译器。它将使用了ECMAScript语言特性的JavaScript代码转换成只使用广泛支持的ES5特性的等价代码</li>
<li>使用方式： <ul>
<li>一种是根据设置文档（<a href="https://babeljs.io/docs/setup/）进行安装。另一种方式是直接在浏览器中试用（https://babeljs.io/repl/）" target="_blank" rel="noopener">https://babeljs.io/docs/setup/）进行安装。另一种方式是直接在浏览器中试用（https://babeljs.io/repl/）</a></li>
</ul>
</li>
</ul>
<h3 id="ECMAScript-2015-的功能"><a href="#ECMAScript-2015-的功能" class="headerlink" title="ECMAScript 2015+的功能"></a>ECMAScript 2015+的功能</h3><p>注： 本小节会略过部分基础的语法介绍，只记录个人学习中部分模糊的概念，详细语法可参见 《深入理解ES6》 一书</p>
<h4 id="用let替代var声明变量"><a href="#用let替代var声明变量" class="headerlink" title="用let替代var声明变量"></a>用let替代var声明变量</h4><ul>
<li>注意点， 同一变量名，var 在同一作用域中可以连续声明 , let不可以</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">'456'</span></span><br><span class="line"><span class="built_in">console</span>.log(test) <span class="comment">//456</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test2 = <span class="string">'789'</span></span><br><span class="line"><span class="keyword">let</span> test2 = <span class="string">'001'</span>  <span class="comment">// 抛出错误 ，这里只能重新赋值  : test2 = '001'</span></span><br></pre></td></tr></table></figure>

<h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><ul>
<li>用一对`包裹。要插入变量的值，放在${}里</li>
<li>模板字面量也可以用于多行的字符串，再也不需要用\n了。只要按下键盘上的Enter就可以换一行</li>
</ul>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同</span></span><br><span class="line"><span class="keyword">let</span> test2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="函数的参数默认值"><a href="#函数的参数默认值" class="headerlink" title="函数的参数默认值"></a>函数的参数默认值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x=<span class="number">1</span>, y=<span class="number">2</span> , z=<span class="number">3</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">2</span>,<span class="number">4</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<h4 id="声明展开和剩余参数"><a href="#声明展开和剩余参数" class="headerlink" title="声明展开和剩余参数"></a>声明展开和剩余参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明展开</span></span><br><span class="line"><span class="keyword">let</span> arr  = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">numFun(...arr)</span><br><span class="line"><span class="comment">// 等同于使用apply</span></span><br><span class="line">numFun.apply(<span class="literal">undefined</span>, arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b, ...c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c.length</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>,<span class="number">6</span>) <span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>).length</span><br><span class="line">&#125;</span><br><span class="line">test2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>,<span class="number">6</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h4 id="增强的对象属性"><a href="#增强的对象属性" class="headerlink" title="增强的对象属性"></a>增强的对象属性</h4><ul>
<li>数组解构</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 等同</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量互换</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[a, b] = [b, a]</span><br><span class="line"><span class="built_in">console</span>.log(a, b)  <span class="comment">// 3,1</span></span><br><span class="line"><span class="comment">// 等同</span></span><br><span class="line"><span class="keyword">let</span> temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br></pre></td></tr></table></figure>

<ul>
<li>属性简写</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">2</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    x,</span><br><span class="line">    y,</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    fun() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用类进行面向对象编程"><a href="#使用类进行面向对象编程" class="headerlink" title="使用类进行面向对象编程"></a>使用类进行面向对象编程</h4><ul>
<li>类声明</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(title, page) &#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title</span><br><span class="line">        <span class="keyword">this</span>.page = page</span><br><span class="line">    &#125;</span><br><span class="line">    showTitle() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> book = <span class="keyword">new</span> Book(<span class="string">'章'</span>, <span class="number">115</span>)</span><br><span class="line">book.showTitle() <span class="comment">// 章</span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends 关键字继承</span></span><br><span class="line">cIass Tbook extends Book &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (title, page, word) &#123;</span><br><span class="line">        <span class="comment">// super 引用父类构造函数</span></span><br><span class="line">        <span class="keyword">super</span>(title, page)</span><br><span class="line">        <span class="keyword">this</span>.word = word</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>属性存取器<ul>
<li>ES2015也可以为类属性创建存取器函数。虽然不像其他面向对象语言（封装概念），类的属性不是私有的，但最好还是遵循一种命名模式。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> name (value) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> name () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 张三</span></span><br><span class="line">person.name = <span class="string">'李四'</span></span><br><span class="line"><span class="built_in">console</span>.log(person._name) <span class="comment">//'李四' 由于不是私有，所以可访问</span></span><br></pre></td></tr></table></figure>

<h4 id="乘方运算符"><a href="#乘方运算符" class="headerlink" title="乘方运算符"></a>乘方运算符</h4><ul>
<li><code>**</code>用于指数级计算</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算圆面积</span></span><br><span class="line"><span class="keyword">const</span> area = <span class="number">3.14</span> * r * r</span><br><span class="line"><span class="comment">// 使用Math.pow 方法</span></span><br><span class="line"><span class="keyword">const</span> area = <span class="number">3.14</span> * <span class="built_in">Math</span>.pow(r, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 使用乘方运算符</span></span><br><span class="line"><span class="keyword">const</span> area = <span class="number">3.14</span> * r ** <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul>
<li>文件 <code>area.js</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circleArea = <span class="function"><span class="params">r</span> =&gt;</span> (r ** <span class="number">2</span>) * <span class="number">3.14</span></span><br><span class="line"><span class="keyword">const</span> squareArea = <span class="function"><span class="params">s</span> =&gt;</span> s ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 导出声明</span></span><br><span class="line"><span class="keyword">export</span> &#123;circleArea, squareArea&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>导入使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意导入时文件的 .js 后缀 可有可无</span></span><br><span class="line"><span class="keyword">import</span> &#123;circleArea, squareArea&#125; <span class="keyword">from</span> <span class="string">'./area'</span></span><br><span class="line"><span class="built_in">console</span>.log(circleArea(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>重命名使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里可以只导入需要的内容， as 进行命名</span></span><br><span class="line"><span class="keyword">import</span> &#123;circleArea <span class="keyword">as</span> cArea&#125; <span class="keyword">from</span> <span class="string">'./area'</span></span><br><span class="line"><span class="built_in">console</span>.log(cArea(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>注意： 也可以在导出时就使用<code>as</code> 重命名,如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;circleArea <span class="keyword">as</span> cArea, squareArea <span class="keyword">as</span> sArea&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时导入就需要使用重新命名的名字</span></span><br><span class="line"><span class="keyword">import</span> &#123;cArea, sArea&#125; <span class="keyword">from</span> <span class="string">'./area'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>导入全部，不需要 <code>{}</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> areaFun <span class="keyword">from</span> <span class="string">'./area'</span></span><br><span class="line"><span class="built_in">console</span>.log(areaFun.circleArea(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(areaFun.squareArea(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>不使用导出声明，直接一条条导出</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> circleArea = <span class="function"><span class="params">r</span> =&gt;</span> (r ** <span class="number">2</span>) * <span class="number">3.14</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> squareArea = <span class="function"><span class="params">s</span> =&gt;</span> s ** <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>假设模块中只有一个成员，而且需要将其导出。可以使用<strong>export default</strong>关键字</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// book.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(title, page) &#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title</span><br><span class="line">        <span class="keyword">this</span>.page = page</span><br><span class="line">    &#125;</span><br><span class="line">    showTitle() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导入 不需要 &#123;&#125;</span></span><br><span class="line"><span class="keyword">import</span> Book <span class="keyword">from</span> <span class="string">'./book'</span></span><br><span class="line"><span class="keyword">const</span> book = <span class="keyword">new</span> Book(<span class="string">'title'</span>)</span><br></pre></td></tr></table></figure>



<p><strong>使用node.js运行ES6模块</strong></p>
<p>由于Node并不原生支持ES6模块， 所以需要相应的处理</p>
<ul>
<li><p>方式一： 对于低版本node, 通过babel转译导出部分的js文件，之后依旧通过<code>require</code>的方式引入</p>
<ul>
<li><p>安装babel</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g babel-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文件转译, 并将转译后的代码放到 lib 文件夹下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel book.js --out-dir lib</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>test.js</code>,在该文件中使用 <code>require</code>的方式导入模块即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Book = <span class="built_in">require</span>(<span class="string">'./lib/book.js'</span>)</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">const</span> book = <span class="keyword">new</span> Book(<span class="string">'title'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方式二： 在node中直接使用ES6导入，不转译</p>
<ul>
<li><p>要求：（作为Node8.5以上的实验功能，Node 10 LTS 稳定支持，有固定使用方式）</p>
</li>
<li><p>首先将 所有的<code>.js</code>文件重命名为 <code>.mjs</code></p>
</li>
<li><p>之后将<code>test.mjs</code>中的导入语句更新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Book <span class="keyword">from</span> <span class="string">'./book.mjs'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在node命令后添加–experimental-modules来执行代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --experimental-modules test.mjs</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><strong>在浏览器中运行ES6模块</strong></p>
<ul>
<li><p>方式一： 使用webpack等打包工具，生成传统的代码包（即转译成ES5代码的JavaScript文件），将js文件直接引入 <code>html</code>文件中 </p>
<ul>
<li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"xxx.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方式二： 自在2017年初，现代浏览器逐步支持ES6模块</p>
<ul>
<li>支持情况可查阅（<a href="http://caniuse.com/#feat=es6-module）" target="_blank" rel="noopener">http://caniuse.com/#feat=es6-module）</a></li>
<li>需要注意：在浏览器中使用import关键字，首先需要在代码的import语句后加上．js文件扩展名</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在test.js中使用book.js</span></span><br><span class="line"><span class="keyword">import</span> Book <span class="keyword">from</span> <span class="string">'./book.js'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在html 文件中引入 <code>test.js</code>,需要在script标签中增加<strong>type=”module”</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.js"</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果想要兼容 不支持模块的浏览器可以使用nomodule 额外写一行代码</span></span><br><span class="line"><span class="comment">这种情况下,支持和不支持的浏览器,会根据情况选择相应的代码去执行</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.js"</span> <span class="attr">nomodule</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="介绍TypeScript"><a href="#介绍TypeScript" class="headerlink" title="介绍TypeScript"></a>介绍TypeScript</h3><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typesScript 允许为变量设置类型</span></span><br><span class="line"><span class="keyword">let</span> age: number = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> name: string = <span class="string">'123'</span></span><br><span class="line"><span class="comment">// 由于TypeScript有类型推断机制，也就是说TypeScript会根据为变量赋的值自动给该变量设置一个类,所以上述代码可以简化</span></span><br><span class="line"><span class="keyword">let</span> age2 = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'456'</span></span><br><span class="line"><span class="comment">// 而在声明变量,未赋值时,推荐设置类型</span></span><br><span class="line"><span class="keyword">let</span> detail: string</span><br></pre></td></tr></table></figure>

<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用情形1: 给变量设置类型</span></span><br><span class="line"><span class="keyword">interface</span> Duck &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    sayName():<span class="built_in">void</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> randomDuck = &#123;</span><br><span class="line">    name: <span class="string">'ab'</span>, </span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> randomDuck2 = &#123;</span><br><span class="line">    name: <span class="string">'cd'</span>, </span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">duckFun</span>(<span class="params">obj: Duck</span>) </span>&#123;</span><br><span class="line">    obj.sayName()</span><br><span class="line">&#125;</span><br><span class="line">duckFun(randomDuck) <span class="comment">// ab</span></span><br><span class="line"><span class="comment">// 尽管这里传入的对象比接口定义的属性要多,但是由于它符合鸭子类型的概念,它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子！在本例中，randomDuck2的行为和Duck接口定义的一样，那么它就是一个Duck。</span></span><br><span class="line">duckFun(randomDuck2) <span class="comment">// cd </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用情形2: 通过类来进行实现 (implements)</span></span><br><span class="line"><span class="keyword">interface</span> Comparable &#123;</span><br><span class="line">    compareTo(b): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> MyObject <span class="keyword">implements</span> Comparable &#123;</span><br><span class="line">    num: <span class="built_in">number</span></span><br><span class="line">    compareTo(b): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.num === b.num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num &gt; b.num ? <span class="number">1</span> : <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型,可以动态的决定类型</span></span><br><span class="line"><span class="comment">// 定义接口, 定义泛型T,并使参数b符合泛型</span></span><br><span class="line"><span class="keyword">interface</span> Comparable&lt;T&gt; &#123;</span><br><span class="line">    compareTo(b: T ): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里将泛型指定为MyObject类,从而使compareTo只能比较相同类型的对象(MyObject)</span></span><br><span class="line"><span class="keyword">class</span> MyObject <span class="keyword">implements</span> Comparable&lt;MyObject&gt; &#123;</span><br><span class="line">    num: <span class="built_in">number</span></span><br><span class="line">    compareTo(b: MyObject): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.num === b.num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num &gt; b.num ? <span class="number">1</span> : <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他TypeScript功能"><a href="#其他TypeScript功能" class="headerlink" title="其他TypeScript功能"></a>其他TypeScript功能</h4><p><a href="https://www.typescriptlang.org/docs/home.html找到" target="_blank" rel="noopener">英文文档</a></p>
<p><a href="https://www.typescriptlang.org/play/index.html" target="_blank" rel="noopener">在线测试地址</a></p>
<h4 id="TypeScript中对JavaScript文件的编译时检查"><a href="#TypeScript中对JavaScript文件的编译时检查" class="headerlink" title="TypeScript中对JavaScript文件的编译时检查"></a>TypeScript中对JavaScript文件的编译时检查</h4><ul>
<li>某些情况下,我们依然会创建<code>.js</code>文件使用普通的javaScript进行开发,而不是创建<code>.ts</code>使用typescript进行开发,但是此时依然可以在JavaScript中使用一些类型和错误检测功能</li>
<li>首先需要全局安装TypeScript</li>
<li>其次在js文件第一行加上 </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-check</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此时类型检查成功启用</li>
</ul>
<h2 id="第三章-数组"><a href="#第三章-数组" class="headerlink" title="第三章 数组"></a>第三章 数组</h2><h3 id="为什么用数组"><a href="#为什么用数组" class="headerlink" title="为什么用数组"></a>为什么用数组</h3><ul>
<li>时间复杂度：删除或添加 O(n)  查找O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存某天各个小时的气温</span></span><br><span class="line"><span class="comment">// 非数组</span></span><br><span class="line"><span class="keyword">let</span> one, two, three = <span class="string">'31.9'</span>, <span class="string">'35.3'</span>, <span class="string">'42.4'</span></span><br><span class="line"><span class="comment">// 这种情况下,如果要存的天数更多,显然要管理的变量也会不断增多,这时可以使用数组,简洁的呈现相同的信息</span></span><br><span class="line"><span class="keyword">const</span> tempArr = []</span><br><span class="line">tempArr[<span class="number">0</span>] = <span class="string">'31.9'</span></span><br><span class="line">tempArr[<span class="number">1</span>] = <span class="string">'35.3'</span></span><br><span class="line">tempArr[<span class="number">2</span>] = <span class="string">'42.4'</span></span><br></pre></td></tr></table></figure>

<p>保存形式如图</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/01.png">

<h3 id="创建和初始化数组"><a href="#创建和初始化数组" class="headerlink" title="创建和初始化数组"></a>创建和初始化数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一 通过new </span></span><br><span class="line"><span class="keyword">let</span> daysOfWeek = <span class="keyword">new</span> <span class="built_in">Array</span>() <span class="comment">// 声明并初始化数组</span></span><br><span class="line">daysOfWeek = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">7</span>)  <span class="comment">// 创建一个长度为7的数组</span></span><br><span class="line">daysOfWeek = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'Sunday'</span>, <span class="string">'Monday'</span>) <span class="comment">// 声明并传入数组元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二 通过 []</span></span><br><span class="line"><span class="keyword">let</span> daysOfWeek = []</span><br><span class="line">daysOfWeek = [<span class="string">'Sunday'</span>, <span class="string">'Monday'</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看存放元素个数 通过length 属性</span></span><br><span class="line">daysOfWeek.length</span><br></pre></td></tr></table></figure>

<ul>
<li>访问和迭代</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问数组可以通过 中括号传递位置  如 a[0], 赋值, a[1] = 5</span></span><br><span class="line"><span class="comment">// 迭代可以通过for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i  = <span class="number">0</span>; i &lt; testArr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(testArr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印斐波那契数列前20个数字(特点: 该数列前两个值是1,之后每个值是前两个值的和)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci  = []</span><br><span class="line">fibonacci[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">fibonacci[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">    fibonacci[i] = fibonacci[i<span class="number">-1</span>] + fibonacci[i<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; fibonacci.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fibonacci[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul>
<li>在末尾插入</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">arr[arr.length] = <span class="number">5</span></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">arr.push(<span class="number">5</span>) <span class="comment">// push 可以添加多个元素  arr.push(5,5,6,7)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在开头插入</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.insertFirstPosition = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>[<span class="number">0</span>] = value</span><br><span class="line">&#125;</span><br><span class="line">arr.insertFirstPosition(<span class="number">6</span>)</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">arr.unshift(<span class="number">6</span>) <span class="comment">// unshift 可以添加多个元素  arr.unshift(6,5,6,1)</span></span><br></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 末尾删除</span></span><br><span class="line">arr.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开头删除</span></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.removeFirstPosition = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将元素值整体前移,此时最后一个元素变为 undefined,应将其去掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="keyword">this</span>[i + <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reIndex(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建reIndex方法去除多余元素</span></span><br><span class="line"><span class="keyword">let</span> reIndex = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newArr = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i  = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            newArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意由于reIndex重新创建并返回了数组,所以这里需要重新赋值,才能更新原数组</span></span><br><span class="line">arr = arr.removeFirstPosition()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">arr.shift()</span><br></pre></td></tr></table></figure>

<h3 id="在任意位置添加或删除元素"><a href="#在任意位置添加或删除元素" class="headerlink" title="在任意位置添加或删除元素"></a>在任意位置添加或删除元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment">// 参数分别是 开始的索引位置 ; 删除元素个数 ; 之后所有参数都是新增的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="二维和多维数组"><a href="#二维和多维数组" class="headerlink" title="二维和多维数组"></a>二维和多维数组</h3><ul>
<li>二维数组保存多日每小时的气温</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = []</span><br><span class="line">temp[<span class="number">0</span>] = [<span class="number">23</span>, <span class="number">16</span>,<span class="number">31</span>, <span class="number">23</span>]</span><br><span class="line">temp[<span class="number">1</span>] = [<span class="number">13</span>, <span class="number">26</span>,<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码还可以写成类似矩阵的效果</span></span><br><span class="line">temp[<span class="number">0</span>] = []</span><br><span class="line">temp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">23</span></span><br><span class="line">temp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">16</span></span><br><span class="line">temp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">31</span></span><br><span class="line">temp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">23</span></span><br><span class="line">temp[<span class="number">1</span>] = []</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">13</span></span><br><span class="line">temp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">26</span></span><br><span class="line">temp[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">11</span></span><br><span class="line">temp[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>可以理解成如图形式,行是每天数据,列是每小时数据</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/02.png">

<ul>
<li>迭代二维数组元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMatrix</span>(<span class="params">myMatrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myMatrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; myMatrix[i].length; j++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(myMatrix[i][j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printMatrix(temp)</span><br></pre></td></tr></table></figure>

<ul>
<li>多维数组 (以三维为例,更多维度同理)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建3维</span></span><br><span class="line"><span class="keyword">const</span> matrix3x3x3 = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    matrix3x3x3[i] = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        matrix3x3x3[i][j] = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">            matrix3x3x3[i][j][k] = i + j + k</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代同理,使用三个for 循环进行遍历即可</span></span><br></pre></td></tr></table></figure>

<p>三维数组效果图</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/03.png">

<h3 id="JavaScript的数组方法参考"><a href="#JavaScript的数组方法参考" class="headerlink" title="JavaScript的数组方法参考"></a>JavaScript的数组方法参考</h3><ul>
<li>此处仅对方法进行列举,详细使用方式不展开介绍</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组合并 : arr.concat()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代方法</span></span><br><span class="line"><span class="comment">// arr.forEach()  迭代数组,与for循环表现一致</span></span><br><span class="line"><span class="comment">// arr.every()  迭代数组 返回值全部为true时返回true </span></span><br><span class="line"><span class="comment">// arr.some() 迭代数组 返回值有true则为true</span></span><br><span class="line"><span class="comment">// arr.map() 返回迭代后值组成的数组</span></span><br><span class="line"><span class="comment">// arr.filter() 返回结果为true的值组成的数组</span></span><br><span class="line"><span class="comment">// arr.reduce((累计值, 当前值, 索引, 源数组)=&gt;&#123;&#125;) 求和函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6新功能 涉及</span></span><br><span class="line"><span class="comment">// for...of   ; Symbol.iterator ; entries, values, keys ; </span></span><br><span class="line"><span class="comment">// Array.from ; Array.of; </span></span><br><span class="line"><span class="comment">//Array.fill()填充数组 参数分别是  用来填充的值 开始索引(可选) 结束索引(可选) ; </span></span><br><span class="line"><span class="comment">// Array.copyWithin() 拷贝数组, 参数分别是 目标位置索引 开始复制元素的起始位置 开始复制元素的结束位置(复制元素不包含该位置,参数可忽略)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序方法</span></span><br><span class="line"><span class="comment">// arr.reverse  反转数组</span></span><br><span class="line"><span class="comment">// arr.sort 排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索方法</span></span><br><span class="line"><span class="comment">// es5 </span></span><br><span class="line"><span class="comment">// arr.indexOf; arr.lastIndexOf</span></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="comment">// arr.find(fn); arr.findIndex(fn)</span></span><br><span class="line"><span class="comment">// arr.includes()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出数组为字符串</span></span><br><span class="line"><span class="comment">// arr.join()</span></span><br><span class="line"><span class="comment">// arr.toString()</span></span><br></pre></td></tr></table></figure>

<h3 id="类型数组"><a href="#类型数组" class="headerlink" title="类型数组"></a>类型数组</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noopener">参考资料</a></p>
<h2 id="第四章-栈"><a href="#第四章-栈" class="headerlink" title="第四章 栈"></a>第四章 栈</h2><p>特点: 后进先出</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/数据结构01.png">



<ul>
<li>js中的栈 –&gt; 函数调用栈<ul>
<li>如: 执行a函数，执行b函数，执行c函数 结束执行c函数 结束执行b函数 结束执行a函数</li>
</ul>
</li>
</ul>
<h3 id="创建基于数组的栈"><a href="#创建基于数组的栈" class="headerlink" title="创建基于数组的栈"></a>创建基于数组的栈</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// push 添加元素到栈顶</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pop 从栈顶移除元素</span></span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// peek 返回栈顶元素</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// isEmpty 判断栈是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear 清空栈内元素</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// size 返回栈内元素个数</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建基于JavaScript对象的Stack类"><a href="#创建基于JavaScript对象的Stack类" class="headerlink" title="创建基于JavaScript对象的Stack类"></a>创建基于JavaScript对象的Stack类</h3><ul>
<li>基于对象的Stack类, 除了 toString 方法,其余方法时间复杂度都是 O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items[<span class="keyword">this</span>.count] = element</span><br><span class="line">        <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count--</span><br><span class="line">        <span class="keyword">let</span> elem = <span class="keyword">this</span>.items[<span class="keyword">this</span>.count]</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count]</span><br><span class="line">        <span class="keyword">return</span> elem</span><br><span class="line">    &#125;</span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = []</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> objStr = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.items[<span class="number">0</span>]&#125;</span>`</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.count; i++) &#123;</span><br><span class="line">            objStr = <span class="string">`<span class="subst">$&#123;objStr&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.items[i]&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objStr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保护数据结构内部元素（私有属性）"><a href="#保护数据结构内部元素（私有属性）" class="headerlink" title="保护数据结构内部元素（私有属性）"></a>保护数据结构内部元素（私有属性）</h3><ul>
<li>如下方代码所示,实例中的属性并没有受保护,栈可以直接访问item属性,并可以通过 {1} {2}的方式进行访问</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count stack = <span class="keyword">new</span> Stack()</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(stack) <span class="comment">// ['count', 'items']  &#123;1&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.keys(stack) <span class="comment">// ['count', 'items']  &#123;1&#125;</span></span><br><span class="line">stack.items <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<ul>
<li>下划线命名约定<ul>
<li>一些开发者会采用下划线得方式命名私有属性,但这只是一种约定,并不具有实际效果</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>._items = &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>._count = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用ES6的Symbol<ul>
<li>通过Symbol定义属性名, 该种方式只能通过特定方法访问,不能直接访问</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _items = <span class="built_in">Symbol</span>(<span class="string">'items'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>[_items] = []</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"><span class="comment">// 只能通过下面的方式访问</span></span><br><span class="line"><span class="keyword">let</span> symbolArr = <span class="built_in">Object</span>.getOwnPropertySymbols(stack)</span><br><span class="line"><span class="built_in">console</span>.log(symbolArr.length) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolArr) <span class="comment">// [Symbol(items)]</span></span><br><span class="line"><span class="built_in">console</span>.log(stack[symbolArr[<span class="number">0</span>]]) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用ES6的WeakMap<ul>
<li>真正的私有属性, 缺点是 代码可读性不强, 类继承时不会继承属性</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="comment">// 这里使用数组实现栈的方式举例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        items.set(<span class="keyword">this</span>, [])</span><br><span class="line">    &#125;</span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>)</span><br><span class="line">        s.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> s.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ECMAScript 类属性提案<ul>
<li>在 TypeScript 中 可以 通过 private 修饰符 定义私有属性,但是该属性只在编译阶段有用,编译完成后,属性同样是公开的</li>
<li>目前<a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">最新提案</a>中可以通过(#) 定义私有属性</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        #items = []</span><br><span class="line">        #count = 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用栈解决问题"><a href="#用栈解决问题" class="headerlink" title="用栈解决问题"></a>用栈解决问题</h3><ul>
<li>从十进制到二进制</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToBinary</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = <span class="keyword">new</span> Stack(), str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span>(number) &#123;</span><br><span class="line">        stack.push(number % <span class="number">2</span>)</span><br><span class="line">        number = <span class="built_in">parseInt</span>(number / <span class="number">2</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        str += stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>十进制转换其它进制算法(基于十进制二进制转换方法进行改造)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1 十进制数字 参数2 要转换的进制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseConverter</span>(<span class="params">number, base</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = <span class="keyword">new</span> Stack(), str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">let</span> digits = <span class="string">'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line">    <span class="keyword">if</span> (!(base &gt;= <span class="number">2</span> &amp;&amp; base &lt;= <span class="number">36</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">while</span>(number) &#123;</span><br><span class="line">        stack.push(number % base)</span><br><span class="line">        number = <span class="built_in">parseInt</span>(number / base)</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">while</span>(!(stack.isEmpty())) &#123;</span><br><span class="line">          str += digits[stack.pop()]</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第五章-队列和双端队列"><a href="#第五章-队列和双端队列" class="headerlink" title="第五章 队列和双端队列"></a>第五章 队列和双端队列</h2><p>特点: 先进先出(FIFO)</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/数据结构02.png">

<h3 id="基于对象创建队列"><a href="#基于对象创建队列" class="headerlink" title="基于对象创建队列"></a>基于对象创建队列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span> <span class="comment">// 指向队列尾</span></span><br><span class="line">        <span class="keyword">this</span>.lowestCount = <span class="number">0</span> <span class="comment">// 指向队头</span></span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125; <span class="comment">// 保存队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    enqueue(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items[<span class="keyword">this</span>.count] = element</span><br><span class="line">        <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> delEle = <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount]</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount]</span><br><span class="line">        <span class="keyword">this</span>.lowestCount++</span><br><span class="line">        <span class="keyword">return</span> delEle</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count - <span class="keyword">this</span>.lowestCount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size() === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看第一个元素</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空队列</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">this</span>.lowestCount = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount]&#125;</span>`</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.lowestCount + <span class="number">1</span>; i &lt; <span class="keyword">this</span>.count; i++) &#123;</span><br><span class="line">            str = <span class="string">`<span class="subst">$&#123;str&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.items[i]&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><ul>
<li>是一种允许同时从前端和后端添加和移除元素的特殊队列,它同时遵守了先进先出和后近先出原则,是一种把队列和栈相结合的数据结构</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.lowestCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从前端添加</span></span><br><span class="line">    addFront(element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123; <span class="comment">// 队列中没有元素</span></span><br><span class="line">            <span class="keyword">this</span>.addBack(element)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.lowestCount &gt; <span class="number">0</span>) &#123; <span class="comment">// 队列从前端移除过元素</span></span><br><span class="line">            <span class="keyword">this</span>.lowestCount--</span><br><span class="line">            <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount] = element</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 队列没有移除过元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.count; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">this</span>.items[i] = <span class="keyword">this</span>.items[i - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.items[<span class="number">0</span>] = element</span><br><span class="line">            <span class="keyword">this</span>.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从后端添加</span></span><br><span class="line">    addBack(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items[<span class="keyword">this</span>.count] = element</span><br><span class="line">        <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从前端删除</span></span><br><span class="line">    removeFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount]</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount]</span><br><span class="line">        <span class="keyword">this</span>.lowestCount++</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从后端删除</span></span><br><span class="line">    removeBack() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count--</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">this</span>.items[<span class="keyword">this</span>.count]</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看前端第一个元素</span></span><br><span class="line">    peekFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看后端最后一个元素</span></span><br><span class="line">    peekBack() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isEmpty clear size toString 方法与 队列一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用队列和双端队列解决问题"><a href="#使用队列和双端队列解决问题" class="headerlink" title="使用队列和双端队列解决问题"></a>使用队列和双端队列解决问题</h3><h4 id="循环队列–击鼓传花游戏"><a href="#循环队列–击鼓传花游戏" class="headerlink" title="循环队列–击鼓传花游戏"></a>循环队列–击鼓传花游戏</h4><ul>
<li>规则: 固定队伍人数 ，通过给出一个固定数字，之后开始在队伍中循环，每次当固定数字和队伍中数字相符时，淘汰这个人，之后继续循环，直到剩一个人为止</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数分别是 人员列表 , 被选数字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">game</span>(<span class="params">listArr, selNum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue(), failArr = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listArr.length; i++) &#123;</span><br><span class="line">        queue.enqueue(listArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(flag !== selNum) &#123;</span><br><span class="line">            <span class="comment">// 这里实际上就是一个循环队列</span></span><br><span class="line">            queue.enqueue(queue.dequeue())</span><br><span class="line">            flag++</span><br><span class="line">        &#125;</span><br><span class="line">        failArr.push(queue.dequeue())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        failArr,</span><br><span class="line">        winner: queue.dequeue()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回文检查器"><a href="#回文检查器" class="headerlink" title="回文检查器"></a>回文检查器</h4><ul>
<li>回文是正反都能读通的单词、词组、数或一系列字符的序列</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用双端队列实现回文检查器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindromeChecker</span>(<span class="params">aString</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (aString === <span class="literal">null</span> || aString === <span class="literal">undefined</span> || (aString !== <span class="literal">null</span> &amp;&amp; aString.length ===<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dequeue = <span class="keyword">new</span> DeQueue()</span><br><span class="line">    <span class="keyword">let</span> isEqual = <span class="literal">true</span>, lastStr, firstStr, lowerStr</span><br><span class="line">    <span class="comment">// 将传入字符串变为小写,并去除其中的空格</span></span><br><span class="line">    lowerStr = aString.toLocaleLowerCase().split(<span class="string">' '</span>).join(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lowerStr.length; i++) &#123;</span><br><span class="line">        dequeue.addBack(lowerStr.charAt(i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(dequeue.size() &gt; <span class="number">1</span> &amp;&amp; isEqual) &#123;</span><br><span class="line">        firstStr = dequeue.removeFront()</span><br><span class="line">        lastStr = dequeue.removeBack()</span><br><span class="line">        <span class="keyword">if</span> (firstStr !== lastStr) &#123;</span><br><span class="line">            isEqual = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEqual</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JavaScript任务队列"><a href="#JavaScript任务队列" class="headerlink" title="JavaScript任务队列"></a>JavaScript任务队列</h4><ul>
<li>在js中,当我们在浏览器中打开新标签时，就会创建一个任务队列, 每个标签都是单线程处理所有的任务，称为事件循环。浏览器要负责多个任务，如渲染HTML、执行JavaScript代码、处理用户交互（用户输入、鼠标点击等）、执行和处理异步请求</li>
</ul>
<h2 id="第六章-链表"><a href="#第六章-链表" class="headerlink" title="第六章 链表"></a>第六章 链表</h2><h3 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h3><p>特点:</p>
<ul>
<li>元素在内存中不一定存储在连续的空间中</li>
<li>每个元素由两部分组成，元素自身以及指向下一个元素的指针</li>
<li>缺点：查找较为麻烦，需要读取所有地址，才能找到对应得元素</li>
<li>优点：插入方便，只需要改前后两个指针，初始的内存空间也不需要固定，根据需要自行扩展</li>
<li>时间复杂度：删除或添加 O(1)  查找O(n)</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/数据结构03.png">

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判等函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultEquals</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a === b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element, next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">        <span class="keyword">this</span>.next = next  <span class="comment">// next 参数一般不用, 默认undefined , 这里设置主要是为了下面双向链表方便继承</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认判断相等的函数使用 defaultEquals ,根据实际情况,也可以自行传入</span></span><br><span class="line">    <span class="keyword">constructor</span>(fnEquals = defaultEquals) &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">this</span>.fnEquals = fnEquals</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向链表结尾插入元素</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element) </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">            <span class="keyword">while</span>(current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                current = current.next</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = node</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过索引查找元素</span></span><br><span class="line">    getElementAt(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index &amp;&amp; current != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                current = current.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> current</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向指定位置插入元素</span></span><br><span class="line">    insert(element, index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">            <span class="keyword">let</span> current</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                current = <span class="keyword">this</span>.head</span><br><span class="line">                node.next = current</span><br><span class="line">                <span class="keyword">this</span>.head = node</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> persious = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">                node.next = persious.next</span><br><span class="line">                persious.next = node</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.count++</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据索引删除元素</span></span><br><span class="line">    removeAt(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;=<span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> current</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                current  = <span class="keyword">this</span>.head</span><br><span class="line">                <span class="keyword">this</span>.head = current.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="keyword">let</span> previous = <span class="keyword">this</span>.getEelementAt(index <span class="number">-1</span>)</span><br><span class="line">                current = previous.next</span><br><span class="line">                previous.next = current.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.count--</span><br><span class="line">            <span class="keyword">return</span> current</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据元素查找索引</span></span><br><span class="line">    indexOf(element) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.equalsFn(current.element, element)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据元素删除</span></span><br><span class="line">    remove(element) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.indexOf(element)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// size</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// isEmpty</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getHead</span></span><br><span class="line">    getHead() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// toString</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.head.element&#125;</span>`</span>, current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.count &amp;&amp; current.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            current = current.next</span><br><span class="line">            str = <span class="string">`<span class="subst">$&#123;str&#125;</span>, <span class="subst">$&#123;current.element&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul>
<li>双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接；而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/数据结构04.png">

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先对链表进行继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element, next, prev) &#123;</span><br><span class="line">        <span class="keyword">super</span>(element, next)</span><br><span class="line">        <span class="keyword">this</span>.prev = prev</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title">Linkedlist</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">        <span class="keyword">super</span>(equalsFn)</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从尾部添加</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">const</span> node  = <span class="keyword">new</span> DoublyNode(element)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.count === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node </span><br><span class="line">            <span class="keyword">this</span>.tail = node</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.tail.next = node</span><br><span class="line">            node.prev = <span class="keyword">this</span>.tail</span><br><span class="line">            <span class="keyword">this</span>.tail = node</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getElementAt(index) 直接继承</span></span><br><span class="line">    <span class="comment">// 插入任意位置</span></span><br><span class="line">    insert(element, index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;=<span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> DoublyNode(element)</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.head = node</span><br><span class="line">                    <span class="keyword">this</span>.tail = node</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = <span class="keyword">this</span>.head</span><br><span class="line">                    <span class="keyword">this</span>.head.prev = node</span><br><span class="line">                    <span class="keyword">this</span>.head = node</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.count === index) &#123;</span><br><span class="line">                <span class="keyword">this</span>.tail.next = node</span><br><span class="line">                node.prev = <span class="keyword">this</span>.tail</span><br><span class="line">                <span class="keyword">this</span>.tail = node</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = getElementAt(index - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">const</span> current = previous.next</span><br><span class="line">                previous.next = node</span><br><span class="line">                node.prev = previous</span><br><span class="line">                node.next = current</span><br><span class="line">                current.prev = node</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.count++</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据位置删除元素</span></span><br><span class="line">    removeAt(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;=<span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.count &gt; index) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.count === <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.head = <span class="literal">undefined</span></span><br><span class="line">                    <span class="keyword">this</span>.tail = <span class="literal">undefined</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next</span><br><span class="line">                    <span class="keyword">this</span>.head.prev = <span class="literal">undefined</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="keyword">this</span>.count - <span class="number">1</span>) &#123;</span><br><span class="line">                current = <span class="keyword">this</span>.tail</span><br><span class="line">                <span class="keyword">this</span>.tail = <span class="keyword">this</span>.tail.prev</span><br><span class="line">                <span class="keyword">this</span>.tail.next = <span class="literal">undefined</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index <span class="number">-1</span>)</span><br><span class="line">                current = previous.next</span><br><span class="line">                previous.next = current.next</span><br><span class="line">                current.next.prev = previous</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.count--</span><br><span class="line">            <span class="keyword">return</span> current.element</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据元素查找位置</span></span><br><span class="line">    indexOf(element) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.equalsFn(current.element, element)) &#123;</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// remove方法与链表一致</span></span><br><span class="line">    <span class="comment">// 查看链表头</span></span><br><span class="line">    getHead() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看链表尾</span></span><br><span class="line">    getTail() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.tail</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// toString</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.head.element&#125;</span>`</span>, current = <span class="keyword">this</span>.head.next</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.count; i++) &#123;</span><br><span class="line">            str = <span class="string">`<span class="subst">$&#123;str&#125;</span>, <span class="subst">$&#123;current.element&#125;</span>`</span></span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inverseToString</span></span><br><span class="line">    inverseToString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tail == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.tail.element&#125;</span>`</span>, current = <span class="keyword">this</span>.tail.prev</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.count; i++) &#123;</span><br><span class="line">            str = <span class="string">`<span class="subst">$&#123;str&#125;</span>, <span class="subst">$&#123;current.element&#125;</span>`</span></span><br><span class="line">            current = current.prev</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空双向链表</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">super</span>.clear() <span class="comment">// 调用链表清空方法</span></span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="literal">undefined</span> <span class="comment">// 清空尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）</p>
<p><strong>单向循环链表</strong></p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/循环链表.png">

<p><strong>双向循环链表</strong></p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/双向循环链表.png">

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向循环链表实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">        <span class="keyword">super</span>(equalsFn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大部分方法可以直接继承,只有push removeAt insert 方法需要做出修改</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取最后一个元素</span></span><br><span class="line">            <span class="keyword">const</span> tailEle = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.count - <span class="number">1</span>)</span><br><span class="line">            tailEle.next = node</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = <span class="keyword">this</span>.head <span class="comment">// 指向开头</span></span><br><span class="line">        <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">    insert(element, index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.head = node</span><br><span class="line">                    node.next = <span class="keyword">this</span>.head</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	                node.next = <span class="keyword">this</span>.head</span><br><span class="line">                    <span class="keyword">this</span>.head = node</span><br><span class="line">                    <span class="keyword">const</span> tailEle = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.count - <span class="number">1</span>)</span><br><span class="line">                    tailEle.next = <span class="keyword">this</span>.head</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">                node.next = previous.next</span><br><span class="line">                previous.next = node</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.count++</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    removeAt(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.count == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.head = <span class="literal">undefined</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.head = current.next</span><br><span class="line">                    <span class="keyword">const</span> tailEle = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.count - <span class="number">1</span>)</span><br><span class="line">                    tailEle.next = <span class="keyword">this</span>.head</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下方代码与链表一致</span></span><br><span class="line">                <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">                current = previous.next</span><br><span class="line">                previous.next = current.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.count--</span><br><span class="line">            <span class="keyword">return</span> current.element</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h3><ul>
<li>有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象保存比较状态</span></span><br><span class="line"><span class="keyword">const</span> compare = &#123;</span><br><span class="line">    LESS_THAN: <span class="number">-1</span>,</span><br><span class="line">    BIGGER_THAN: <span class="number">1</span>,</span><br><span class="line">    EQUALS: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a , b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="keyword">return</span> compare.EQUALS</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? compare.LESS_THAN : compare.BIGGER_THAN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals, compareFn = defaultCompare) &#123;</span><br><span class="line">        <span class="keyword">super</span>(equalsFn)</span><br><span class="line">        <span class="keyword">this</span>.compareFn = compareFn</span><br><span class="line">    &#125;</span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 本身无元素复用原有方法</span></span><br><span class="line">            <span class="keyword">super</span>.push(element)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 本身有元素, 通过排序,得到元素位置,之后复用insert 方法,插入元素</span></span><br><span class="line">            <span class="keyword">const</span> index = getIndexNextSortedElement(element)</span><br><span class="line">            <span class="keyword">super</span>.insert(element, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insert(element, index = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.insert(element, index === <span class="number">0</span> ? index : <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> index = getIndexNextSortedElement(element)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.insert(element, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取排序元素位置</span></span><br><span class="line">    getIndexNextSortedElement(element) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>, current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">for</span> ( ; i &lt; <span class="keyword">this</span>.count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare.LESS_THAN === <span class="keyword">this</span>.compareFn(element, current.element)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建StackLinkedList类"><a href="#创建StackLinkedList类" class="headerlink" title="创建StackLinkedList类"></a>创建StackLinkedList类</h3><ul>
<li>即基于链表创建栈,时间复杂度O(1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> DoublyLinkedList()</span><br><span class="line">    &#125;</span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.removeAt(<span class="keyword">this</span>.size() - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.peekTail()</span><br><span class="line">    &#125;</span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.size()</span><br><span class="line">    &#125;</span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.clear()</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第七章-集合"><a href="#第七章-集合" class="headerlink" title="第七章 集合"></a>第七章 集合</h2><ul>
<li>集合是由一组无序且唯一（即不能重复）的项组成的</li>
<li>在数学中，集合是一组不同对象的集。比如说，一个由大于或等于0的整数组成的自然数集合：N = {0, 1, 2, 3, 4, 5, 6,…}。集合中的对象列表用花括号（{}）包围。空集用{ }表示。</li>
</ul>
<h3 id="创建集合类"><a href="#创建集合类" class="headerlink" title="创建集合类"></a>创建集合类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判端元素是否存在, 这里使用hasOwnProperty方法进行判断,之所以没有使用 this.hasOwnProperty的写法,是因为类似于ESlint的检查器可能会抛出异常, 因为不能保证this一定继承了Object中的hasOwnproperty方法,哪怕继承了也不能保证该方法没有被重写</span></span><br><span class="line">    has(element) &#123;  </span><br><span class="line">        <span class="comment">// 一点个人的疑惑 为什么这里不用 this.items[element] !== undefined的方式来判断是否存在,原因是因为哪怕他的值是undefined 也不能证明没有这个属性,有可能只是将这个属性的值设置为了undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(<span class="keyword">this</span>.items, element)</span><br><span class="line">    &#125;</span><br><span class="line">    add(element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.has(element)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.items[element] = element</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>(element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.has(element)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>.items[element]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="comment">// 这里由于没有像上文那样定义count 变量所以,通过其他方法计算size</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items).length</span><br><span class="line">    &#125;</span><br><span class="line">    values() &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        return Object.values(this.items) // es7 方法返回对象值组成的数组</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 另一种写法 通过for..in 得到属性名 通过hasOwnProperty判断是否是自身属性</span></span><br><span class="line">        <span class="keyword">const</span> arr = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnproperty.call(<span class="keyword">this</span>.items, key)) &#123;</span><br><span class="line">                arr.push(<span class="keyword">this</span>.items[key])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">this</span>.size() === <span class="number">0</span> </span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> values = <span class="keyword">this</span>.values()</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">`<span class="subst">$&#123;values[<span class="number">0</span>]&#125;</span>`</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            str = <span class="string">`<span class="subst">$&#123;str&#125;</span>, <span class="subst">$&#123;values[i]&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ... 集合运算方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><ul>
<li>关于纯函数: union、intersection和difference方法不会修改当前的Set类实例或是作为参数传入的otherSet。没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果</li>
</ul>
<h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><ul>
<li>对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/并集.png">

<ul>
<li>代码实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//..</span></span><br><span class="line"> union(otherSet) &#123;</span><br><span class="line">     <span class="keyword">const</span> unionSet  = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">     <span class="keyword">this</span>.values().forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> unionSet.add(value))</span><br><span class="line">     otherSet.values().forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> unionSet.add(value))</span><br><span class="line">     <span class="keyword">return</span> unionSet</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//..</span></span><br></pre></td></tr></table></figure>

<h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><ul>
<li>对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/交集.png">

<ul>
<li>代码实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">  intersection(otherSet) &#123;</span><br><span class="line">      <span class="keyword">const</span> interSectionSet  = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">      <span class="keyword">const</span> currentValues = <span class="keyword">this</span>.values()</span><br><span class="line">      currentValues.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (otherSet.has(value)) &#123;</span><br><span class="line">              interSectionSet.add(value)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> interSectionSet</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面求交集的写法存在一个问题,如果 currentValues也就是第一个集合的长度过长,那么整体循环的次数就会变大,所以可以通过减少循环次数的方式进行优化</span></span><br><span class="line">	intersection(otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> interSectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        <span class="keyword">let</span> biggerSet = <span class="keyword">this</span>.values()</span><br><span class="line">        <span class="keyword">let</span> smallerSet = otherSet.values()</span><br><span class="line">        <span class="keyword">if</span> (biggerSet.length - smallSet.length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> toggle = biggerSet</span><br><span class="line">            biggerSet = smallerSet</span><br><span class="line">            smallerSet = toggle</span><br><span class="line">        &#125;</span><br><span class="line">        smallerSet.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (biggerSet.includes(value)) &#123;</span><br><span class="line">                interSectionSet.add(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> interSectionSet</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><ul>
<li>对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/差集.png">

<ul>
<li>代码实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">	difference(otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">        <span class="keyword">const</span> values = <span class="keyword">this</span>.values()</span><br><span class="line">        values.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!otherSet.has(value)) &#123;</span><br><span class="line">                differenceSet.add(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> differenceSet</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<h4 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h4><ul>
<li>验证一个给定集合是否是另一集合的子集 (数学符号∀代表所有,任意)</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/子集.png">

<ul>
<li>代码实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">	isSubsetof(otherSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (otherSet.size() &lt; <span class="keyword">this</span>.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> values = <span class="keyword">this</span>.values()</span><br><span class="line">        <span class="keyword">let</span> isSubset = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// every 全部为真时返回true 只要循环中有一次为false 就中断循环</span></span><br><span class="line">        values.every(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!otherSet.has(value)) &#123;</span><br><span class="line">                isSubset = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> isSubset</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<h3 id="ECMAScript2015中的Set类"><a href="#ECMAScript2015中的Set类" class="headerlink" title="ECMAScript2015中的Set类"></a>ECMAScript2015中的Set类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add(1)</span><br><span class="line"><span class="keyword">set</span>.has(1) // true</span><br><span class="line"><span class="keyword">set</span>.size // 1 es6中的size 作为属性存在</span><br><span class="line"><span class="keyword">set</span>.values() //@iterator es6 中的values方法，不返回数组，而是返回一个迭代器，可以使用for .. of 进行遍历</span><br><span class="line"><span class="keyword">set</span>.delete(1) </span><br><span class="line"><span class="keyword">set</span>.forEach((vallue, key, self) =&gt; &#123;&#125;)   <span class="comment">// forEach方法 参数分别是 保存的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化set类,传入一个数组,重复的值会被忽略</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>原生Set类不支持集合运算，需要的话，也可以模拟实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入数组初始化set</span></span><br><span class="line"><span class="keyword">const</span> firstSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">const</span> secSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment">// 模拟实现并集 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span> (<span class="params">setA, setB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="comment">// 使用forEach遍历值</span></span><br><span class="line">    setA.forEach(<span class="function"><span class="params">value</span> =&gt;</span> unionSet.add(value))</span><br><span class="line">    setB.forEach(<span class="function"><span class="params">value</span> =&gt;</span> unionSet.add(value))</span><br><span class="line">    <span class="keyword">return</span> unionSets</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里这种写法只介绍并集,其他集合写法,与上文我们实现的集合运算基本一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外介绍另外一种简写的方式 (利用扩展运算符)</span></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">setA, setB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...setA, ...setB]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">setA, setB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([..setA].filter(<span class="function"><span class="params">value</span> =&gt;</span> setB.has(value)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">difference</span>(<span class="params">setA, setB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...setA].filter(<span class="function"><span class="params">value</span> =&gt;</span> !<span class="keyword">set</span>.has(value)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第八章-字典和散列表-哈希表"><a href="#第八章-字典和散列表-哈希表" class="headerlink" title="第八章 字典和散列表(哈希表)"></a>第八章 字典和散列表(哈希表)</h2><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li><p>也叫映射(Map)，一个抽象的数据结构，它包含着类似于，键(key)-&gt;值(value)的对，下文中要介绍的散列表实际上也是解决字典问题的一种实现方式</p>
</li>
<li><p>这里使用对象实现字典（未采用原书中的写法）</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    has(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(<span class="keyword">this</span>.items, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.has(key)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.items[key] = value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.has(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[key]</span><br><span class="line">    &#125;</span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.keys().length</span><br><span class="line">    &#125;</span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    keys() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line">    values() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>es6</code>中，使用<code>Map</code>实现字典<ul>
<li>补充：<code>es6中</code>的<code>Weakmap</code>只存放对象的弱引用，当该对象的强引用被删除时，<code>WeakMap</code>中的弱引用也会被清除，<code>Map</code>则不会</li>
</ul>
</li>
</ul>
<h3 id="散列表-哈希表"><a href="#散列表-哈希表" class="headerlink" title="散列表(哈希表)"></a>散列表(哈希表)</h3><ul>
<li>注： 这里实现散列表的流程并未完全按照原书，增加了一些知识点的解释分析</li>
</ul>
<h4 id="散列表的理解"><a href="#散列表的理解" class="headerlink" title="散列表的理解"></a>散列表的理解</h4><ul>
<li>是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</li>
<li>它基于数组，但是完善了数组插入删除效率低的缺点 插入删除都接近<code>O(1)</code> 速度比树还要快</li>
<li>缺点</li>
<li>1.数据无序</li>
<li>2.不允许重复</li>
</ul>
<h4 id="如何定义key"><a href="#如何定义key" class="headerlink" title="如何定义key"></a>如何定义key</h4><ul>
<li><p>1.因为他是根据key值访问，所以我们就要设计一个实现key的方法</p>
</li>
<li><p>比如：一个散列表中保存了许多单词，每个单词都有释义，例句等等信息，如果想要查找某个单词，我们显然不能通过数字来找，这时就可以设置一个编码格式 (ASCII UTF-8 等等)，在查询时，输入单词名（key），通过计算单词的编码值，得到他的位置，从而实现快速查找，插入也是如此，通过赋予新单词一个新的编码值，来快速保存</p>
</li>
<li><p>2.如何转化：</p>
</li>
<li><p>这里为了方便计算，我们自己设置一种编码方式</p>
</li>
<li><p>a-z 代表十进制 1-26 空格 代表十进制的 0</p>
</li>
<li><p>首先不能通过单纯的加来计算编码，因为这样会出现重复码值得情况，如<code>abc</code> 和 <code>f</code>的码值就相同</p>
</li>
<li><p>其次，可以考虑使用幂的连乘 如 <code>abc</code> : 1 * 27^2^ + 2 * 27^1^ + 3 * 27^0^ 这样基本不会造成重复，但占用内存过大，有很多浪费的空间 所以同样排除</p>
<ul>
<li>补充：上述连乘的思路来源,每个字母在每个位置包括空格的0一共有27个,所以可以将它看成27位进1，这样就能枚举所有的可能，因为数组下标是10进制，所以我们再将27进制转为10进制就能得到上述方法。缺点也如上述所说，实际单词远远没有枚举所展示的那么多，有很多空位所以需要考虑其他方法</li>
</ul>
</li>
<li><p>最终方法 ：哈希化</p>
</li>
</ul>
<h4 id="哈希化-哈希函数-哈希表的关系"><a href="#哈希化-哈希函数-哈希表的关系" class="headerlink" title="哈希化 哈希函数 哈希表的关系"></a>哈希化 哈希函数 哈希表的关系</h4><ul>
<li>哈希化：将大数字转化成数组下标的过程称为哈希化</li>
<li>哈希函数： 我们通过会将实现哈希化的代码放在一个函数中，这个函数就称为哈希函数</li>
<li>哈希表： 将数据存放哈希函数得到的地址中，形成一一对应关系的表，这个表就是哈希表</li>
</ul>
<h4 id="哈希表的常见构造方法："><a href="#哈希表的常见构造方法：" class="headerlink" title="哈希表的常见构造方法："></a>哈希表的常见构造方法：</h4><ul>
<li>直接定址法  <ul>
<li>例如有 1到 100岁的人口统计表，年龄为关键字,哈希函数就直接取关键字自身</li>
</ul>
</li>
<li>数字分析法  <ul>
<li>比如有生日数据为 98.10.01   97.11.21    97.03.05</li>
<li>通过分析发现 前三位易重复，后三位随机性更大，所以取后三位</li>
</ul>
</li>
<li>平方取中法 <ul>
<li>取关键字平方后的中间几位位哈希地址</li>
</ul>
</li>
<li>折叠法 <ul>
<li>将关键字分为位数相同的几部分(最后一部分位数可以不同)，然后取这几部分的叠加和(舍去进位形成哈希地址)</li>
</ul>
</li>
<li>除留余数法  <ul>
<li>取关键字key除以表长p所得余数为哈希地址</li>
</ul>
</li>
<li>随机数法<ul>
<li>选择一个随机函数，取关键字的随机函数值为它的哈希地址</li>
</ul>
</li>
</ul>
<h4 id="解决哈希表冲突的方法"><a href="#解决哈希表冲突的方法" class="headerlink" title="解决哈希表冲突的方法"></a>解决哈希表冲突的方法</h4><p>注：引起冲突的原因，哈希函数计算的保存数据的地址重复</p>
<ul>
<li><p>拉链法(链地址法)：拉出一个动态链代替静态顺序结构，可以避免冲突，但缺点是设计麻烦，增加了编程复杂度</p>
<ul>
<li>（这里不光拉出链表可以，拉出数组也可以，因为在第一次根据哈希化的地址找到对应的数组或链表后，在查找具体的数据，都是通过线性查找，一个个再具体找到的，不能一次性得到，这样查找的效率基本上是一致的</li>
<li>注：子数组只能线性查找的原因是，我们保存的只有哈希化的静态数组地址，没有子数组的地址，所以子数组也只能线性）</li>
<li>补充： 拉出数组可以还有一个前提，那就是冲突的数据是插在拉出的数组最后的，如果是插在前面，则还是使用链表，因为数组插入前面的时间复杂度为O(n)</li>
</ul>
</li>
</ul>
<p>  <strong>2.</strong>设记录关键字集合 key={32,13,49,55,22,39,20}，选取哈希函数为 H(x)=key mod 7；解决冲突的方法为“链地址法”。</p>
<p>  <strong>（1</strong>）画出所构造的哈希表；</p>
<p>  <strong>（2</strong>）求该哈希表查找成功和查找不成功情况下的平均查找长度</p>
<p>  <strong>（1**</strong>）</p>
  <img src="/2021/11/04/学习JavaScript数据结构与算法/散列表01.png">

<ul>
<li><p>成功：每个数据几次插到链尾的和/数据数量</p>
</li>
</ul>
<p>  <strong>成功：ASLsucc= (1*4+2*2+3)/7=11/7;</strong> </p>
<p>  不成功：每个链前面有几个数据的和 除以数组长</p>
<p>  <strong>不成功：ASLnsucc= (1+1+2+3)/7=7/7=1</strong></p>
  <img src="/2021/11/04/学习JavaScript数据结构与算法/散列表02.png">



<ul>
<li><p>开放地址法 ：也细分为多种方法</p>
<ul>
<li>线性探测法； 冲突时 将原本地址，向后移一位，如果再冲突，再向后移，直到不冲突位置</li>
</ul>
<p>例：</p>
<p><strong>1.</strong> <strong>设记录关键字集合 key={33,20,53,55,23,38,40,65}</strong>，选取哈希函数为 H(x)=key mod 11；解决冲突的方法为“线性探测法”。</p>
<p><strong>（1</strong>）请按上述条件将 key <strong>中各值依次填入下表中：</strong></p>
<table>
<thead>
<tr>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
<th><strong>7</strong></th>
<th><strong>8</strong></th>
<th><strong>9</strong></th>
<th><strong>10</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>33</strong></td>
<td><strong>55</strong></td>
<td><strong>23</strong></td>
<td><strong>65</strong></td>
<td></td>
<td><strong>38</strong></td>
<td></td>
<td><strong>40</strong></td>
<td></td>
<td><strong>20</strong></td>
<td><strong>53</strong></td>
</tr>
</tbody></table>
<p> ==补充== 拿65举例，如果查找到结尾还是没位置，会从头重新开始找，直到找到位置</p>
<p><strong>（2</strong>）求该哈希表查找成功和查找不成功情况下的平均查找长度。</p>
<p>成功平均查找长度： 每次查找次数和/ 数据长度</p>
<p><strong>成功：(1+2+2+5+1+1+1+2)/8=15/8;</strong> </p>
<p>不成功平均查找长度： </p>
<p><strong>不成功：(5+4+3+2+1+2+1+2+1+7+6)/11=34/11</strong></p>
</li>
</ul>
<ul>
<li>二次探测法： 冲突时 从 +1 ，-1 ， +4 ，-4 ，+9 ，-9…..开始依次向两边探测，直到有空位为止</li>
</ul>
<ul>
<li><p>多哈希法(再哈希法)：设置二种甚至多种哈希函数，来避免冲突</p>
<ul>
<li>比如设置两种哈希函数 第二种需要具备以下特点:</li>
<li>新的哈希函数需要和前面的哈希函数不同</li>
<li>哈希函数不能输出为0 </li>
<li>下面的双散列法就是一个完整的例子</li>
</ul>
</li>
<li><p>双散列法：  根据双散列函数</p>
</li>
<li><p>h(k,i)=(k mod h + i(1+k mod z)) mod h 进行计算</p>
</li>
<li><p>k是插入的数据默认映射地址  i为探测次数 第一次是0之后每次加1 mod为取模  h为数组长度(为质数)  z为h下的最大质数</p>
</li>
<li><p>比如插入59 得到位置4 但如果位置4已被占用</p>
</li>
<li><p>h(59,0)=(59 mod 11 + 0*(1+59 mod 9)) mod 11=4</p>
</li>
<li><p>则计算下一次 得到10 如果10为空则插入，如果不为空，按照此方式继续计算</p>
</li>
<li><p>h(59,1)=(59 mod 11 + 1*(1+59 mod 9)) mod 11=10</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/散列表03.png">

</li>
</ul>
<p>==注意== 开放地址法有一个需要注意的问题，比如，我们使用线性探测，来解决冲突，假设相同哈希的数据出现在数组 1,2,3 的位置， 这时我们删除 位置1 数据的时候，注意不能将其设为 null 因为如果这样我们查询 位置2 位置3 的数据 就会先根据哈希表的key查找 1 发现1 为空 ，就会认为数据不存在，从而返回false ，所以一般情况下，删除掉的数据，我们将其值，设为 -1 来避免上述情况</p>
<h4 id="哈希化的效率"><a href="#哈希化的效率" class="headerlink" title="哈希化的效率"></a>哈希化的效率</h4><ul>
<li>如果无冲突，效率很高</li>
<li>如果有冲突，存取时间就依赖后来的探测长度</li>
<li>平均探测长度以及平均存取时间，取决于<code>装填因子(Load Factor)</code> </li>
<li>装填因子 = 总数据项 / 哈希表的长度</li>
<li>开放地址法的装填因子最大是 1 </li>
<li>链地址法 可以大于1 因为拉链可以无限延伸下去</li>
<li>通过分析可以得出 同等长的数组，随着数据项的增长哈希化效率更高的是链地址法</li>
</ul>
<h4 id="哈希表的长度"><a href="#哈希表的长度" class="headerlink" title="哈希表的长度"></a>哈希表的长度</h4><ul>
<li>开放地址法数组长度应该尽量取质数 </li>
<li>如果不是质数 比如15（下标为0~14） ，那么如果步长为5   有一个特定关键字默认映射在0  它的探测序列就会在 0， 5，10 之间一直往复循环，从而形成死循环</li>
<li>而如果取 质数 13(下标为0~12) 步长为 5  关键字映射在0  那么探测序列就是 0，5 ， 10 ，2  ，7 ，12 ，4 ，9 ，1 ，6 ，11  ，3 ，8完全不会出现冲突问题</li>
<li>注： 这里的步长就是指每一次探测的长度 是根据哈希函数的值来确定的</li>
<li>链地址法不会出现这种问题，长度没有硬性要求</li>
</ul>
<h4 id="简单构建哈希表"><a href="#简单构建哈希表" class="headerlink" title="简单构建哈希表"></a>简单构建哈希表</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个可以将指定值转为字符串的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultToStr</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Null'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Undefined'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(target)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义单个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValuePair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key,val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">        <span class="keyword">this</span>.val = val</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`#[<span class="subst">$&#123;<span class="keyword">this</span>.key&#125;</span>: <span class="subst">$&#123;<span class="keyword">this</span>.val&#125;</span>]`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(toStrFn = defaultToStr) &#123;</span><br><span class="line">        <span class="comment">// 这里使用对象保存哈希表</span></span><br><span class="line">        <span class="keyword">this</span>.table = &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.toStrFn = toStrFn</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义具体哈希函数</span></span><br><span class="line">    loseloseHashCode(key) &#123;</span><br><span class="line">        <span class="comment">// 如果是数字，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'number'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> strKey = <span class="keyword">this</span>.toStrFn(key), hashKey = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strKey.length; i++) &#123;</span><br><span class="line">            hashKey += strKey.charCodeAt(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashKey % <span class="number">37</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通用hash函数，用于调用指定hasn</span></span><br><span class="line">    hashCode(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> loseloseHashCode(key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据存入哈希表</span></span><br><span class="line">    put(key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> hashkey = <span class="keyword">this</span>.hashCode(key)</span><br><span class="line">            <span class="keyword">this</span>.table[hashkey] = <span class="keyword">new</span> ValuePair(key, value)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看指定数据</span></span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">        <span class="keyword">let</span> hashkey = <span class="keyword">this</span>.hashCode(key)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.table[hashkey] != <span class="literal">null</span> ? <span class="keyword">this</span>.table[hashkey].val : <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除指定数据</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="keyword">const</span> hashkey = <span class="keyword">this</span>.hashCode(key)</span><br><span class="line">        <span class="keyword">const</span> valuePair = <span class="keyword">this</span>.table[hashkey]</span><br><span class="line">        <span class="keyword">if</span> (valuePair != <span class="literal">null</span>) &#123;</span><br><span class="line">	        <span class="keyword">delete</span> <span class="keyword">this</span>.table[hashkey]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回完整哈希表</span></span><br><span class="line">    getTable() &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">this</span>.table</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断哈希表是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size() === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询保存键值对个数</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.table).length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空哈希表</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.table = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换字符串</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">''</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.table).forEach(<span class="function"><span class="params">hashKey</span> =&gt;</span> &#123;</span><br><span class="line">            str += <span class="string">`<span class="subst">$&#123;hashKey&#125;</span> --<span class="subst">$&#123;<span class="keyword">this</span>.table[hashKey].toString()&#125;</span>`</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="散列集合"><a href="#散列集合" class="headerlink" title="散列集合"></a>散列集合</h4><p>概念： 散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是hashCode函数。可以复用本章中实现的所有代码来实现散列集合，不同之处在于，不再添加键值对，而是只插入值而没有键。</p>
<h4 id="处理冲突方法实现-链地址法"><a href="#处理冲突方法实现-链地址法" class="headerlink" title="处理冲突方法实现-链地址法"></a>处理冲突方法实现-链地址法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略相同方法</span></span><br><span class="line">    put(key,value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> hashKey = <span class="keyword">this</span>.hashCode(key)</span><br><span class="line">            <span class="keyword">const</span> valuePair = <span class="keyword">new</span> ValuePair(key, value)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.table[hashKey] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.table[hashKey] = <span class="keyword">new</span> LinkedList()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.table[hashKey].push(valuePair)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">        <span class="keyword">let</span> hashKey = <span class="keyword">this</span>.hashCode(key)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.table[hashKey] != <span class="literal">null</span> &amp;&amp; !<span class="keyword">this</span>.table[hashKey].isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = <span class="keyword">this</span>.table[hashKey].getHead()</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.element.key === key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> node.element.val</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">     &#125;</span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="keyword">let</span> hashKey = <span class="keyword">this</span>.hashCode(key)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.table[hashKey] != <span class="literal">null</span> &amp;&amp; !<span class="keyword">this</span>.table[hashKey].isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = <span class="keyword">this</span>.table[hashKey].getHead()</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.element.key === key) &#123;</span><br><span class="line">					<span class="keyword">this</span>.table[hashKey].remove(node.element)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.table[hashKey].isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">delete</span> <span class="keyword">this</span>.table[hashKey]</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理冲突方法实现-线性探测"><a href="#处理冲突方法实现-线性探测" class="headerlink" title="处理冲突方法实现-线性探测"></a>处理冲突方法实现-线性探测</h4><p>如图： 当想向表中某个位置添加一个新元素的时候，如果索引为position的位置已经被占据了，就尝试position+1的位置。如果position+1的位置也被占据了，就尝试position+2的位置，以此类推，直到在散列表中找到一个空闲的位置</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/线性探测.png">

<p>该方法存在的<strong>问题</strong> ： 当我们从散列表中移除一个键值对的时候，仅使用最初的元素移除方式是不够的。如果我们只是移除了元素，就可能在<strong>查找有相同hash（位置）的其他元素时找到一个空的位置</strong>，这会导致算法出现问题</p>
<p>解决方式一： <strong>软删除</strong></p>
<p>我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/软删除.png">



<p>解决方式二： 移动元素</p>
<p>方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/移动元素.png">



<blockquote>
<p>这里选择方法2 进行实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>() </span>&#123;</span><br><span class="line">    put(key,value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">	        <span class="keyword">let</span> hashKey = <span class="keyword">this</span>.hashCode(key)</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.table[hashKey] != <span class="literal">null</span>) &#123;</span><br><span class="line">                hashKey += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.table[hashKey] = <span class="keyword">new</span> VaulePair(key,  value)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">        <span class="keyword">let</span> hashKey = <span class="keyword">this</span>.hashCode(key)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.table[hashKey] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> valuePair = <span class="keyword">this</span>.table(hashKey)</span><br><span class="line">            <span class="keyword">while</span> (valuePair != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (valuePair.key === key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> valuePair.value</span><br><span class="line">                &#125;</span><br><span class="line">                hashKey += <span class="number">1</span></span><br><span class="line">                valuePair = <span class="keyword">this</span>.table(hashKey)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="keyword">let</span> hashKey = <span class="keyword">this</span>.hashCode(key)</span><br><span class="line">        <span class="keyword">let</span> removePosition = hashKey</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.table[removePosition] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> valuePair = <span class="keyword">this</span>.table(removePosition)</span><br><span class="line">            <span class="keyword">while</span> (valuePair != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (valuePair.key === key) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> <span class="keyword">this</span>.table(removePosition)</span><br><span class="line">                    <span class="keyword">this</span>.moveValuePair(removePosition)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                removePosition += <span class="number">1</span></span><br><span class="line">                valuePair = <span class="keyword">this</span>.table(removePosition)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动空位，参数是计算出的hashCode和最终删除时的position</span></span><br><span class="line">    moveValuePair(position) &#123;</span><br><span class="line">        <span class="keyword">let</span> curPosition = position + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.table[curPosition] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> curHashKey = <span class="keyword">this</span>.hashCode(<span class="keyword">this</span>.table[curPosition].key)</span><br><span class="line">            <span class="comment">// 1.比较他们hashCode后的值， 是因为hashCode才能保证获取到的值类型是一致的， key则不一定一致</span></span><br><span class="line">            <span class="comment">// 2.比较的两个值一个curHashKey 是预计将要移动的值， position是当前位置为空得值</span></span><br><span class="line">            <span class="keyword">if</span> (curHashKey &lt;= position) &#123;</span><br><span class="line">                <span class="keyword">this</span>.table[position] = <span class="keyword">this</span>.table[curPosition]</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>.table[curPosition]</span><br><span class="line">                position =  curPosition</span><br><span class="line">            &#125;</span><br><span class="line">            curPosition += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更好的哈希函数-djb2"><a href="#更好的哈希函数-djb2" class="headerlink" title="更好的哈希函数- djb2"></a>更好的哈希函数- djb2</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>() </span>&#123;</span><br><span class="line">    djb2HashCode(key) &#123;</span><br><span class="line">        <span class="keyword">const</span> strKey = <span class="keyword">this</span>.toStrFn(key)</span><br><span class="line">        <span class="keyword">let</span> hashKey = <span class="number">5381</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strKey.length; i++) &#123;</span><br><span class="line">            hashKey = (hashKey * <span class="number">33</span>) + strKey.charCodeAt(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashKey % <span class="number">1013</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==哈希表的优缺点==</p>
<p>优点: 插入 删除 查询效率都很高<code>O(1)</code></p>
<p>缺点：空间利用率不高，底层使用数组，某些单元没有被利用； 元素是无序的，无法遍历 ； 不能快速的找出哈希表中最大值或最小值这些特殊的值</p>
<h3 id="ES6中的-Map-WeakSet-WeakMap"><a href="#ES6中的-Map-WeakSet-WeakMap" class="headerlink" title="ES6中的 Map , WeakSet, WeakMap"></a>ES6中的 Map , WeakSet, WeakMap</h3><ul>
<li>Map</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'Gandalf'</span>, <span class="string">'gandalf@email.com'</span>);</span><br><span class="line">map.set(<span class="string">'John'</span>, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">map.set(<span class="string">'Tyrion'</span>, <span class="string">'tyrion@email.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'Gandalf'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">// MapIterator &#123;"Gandalf", "John", "Tyrion"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">// MapIterator &#123;"gandalf@email.com", "johnsnow@email.com", "tyrion@email.com"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'Tyrion'</span>)); <span class="comment">// tyrion@email.com</span></span><br><span class="line"></span><br><span class="line">map.delete(<span class="string">'John'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">// MapIterator &#123;"Gandalf", "Tyrion"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">// MapIterator &#123;"gandalf@email.com", "tyrion@email.com"&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>WeakMap, WeakSet 与Map Set的区别是</strong></p>
<blockquote>
<p>WeakSet或WeakMap类没有entries、keys和values等方法；(<strong>不可枚举</strong>)</p>
<p>只能用<strong>对象</strong>作为键。</p>
</blockquote>
<p>结论：因为这个特性，两者的引用是弱引用，所以当作为键的对象被清除时，垃圾回收器可以清空整个入口</p>
<ul>
<li>WeakMap</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ob1 = &#123; <span class="attr">name</span>: <span class="string">'Gandalf'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> ob2 = &#123; <span class="attr">name</span>: <span class="string">'John'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> ob3 = &#123; <span class="attr">name</span>: <span class="string">'Tyrion'</span> &#125;;</span><br><span class="line"><span class="comment">// 可以发现键名都是对象</span></span><br><span class="line">map.set(ob1, <span class="string">'gandalf@email.com'</span>);</span><br><span class="line">map.set(ob2, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">map.set(ob3, <span class="string">'tyrion@email.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(ob1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(ob2)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(ob3)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(ob3)); <span class="comment">// tyrion@email.com</span></span><br><span class="line"></span><br><span class="line">map.delete(ob2);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(ob2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>WeakSet</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = new WeakSet();</span><br><span class="line"></span><br><span class="line">const ob1 = &#123; name: <span class="string">'Gandalf'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> ob2 = &#123; <span class="attr">name</span>: <span class="string">'John'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> ob3 = &#123; <span class="attr">name</span>: <span class="string">'Tyrion'</span> &#125;;</span><br><span class="line"><span class="comment">// 对于set来说， 这里add方法设置值的同时 ，也同样将对象初始化为键</span></span><br><span class="line"><span class="keyword">set</span>.add(ob1);</span><br><span class="line"><span class="keyword">set</span>.add(ob2);</span><br><span class="line"><span class="keyword">set</span>.add(ob3);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(ob1)); // true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(ob2)); // true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(ob3)); // true</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.delete(ob2);</span><br><span class="line">console.log(<span class="keyword">set</span>.has(ob2)); // false</span><br></pre></td></tr></table></figure>

<h2 id="第九章-递归"><a href="#第九章-递归" class="headerlink" title="第九章 递归"></a>第九章 递归</h2><h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><ul>
<li>函数不断的<strong>直接或间接的调用自身</strong>就是递归</li>
<li>为了防止无限递归， 每个递归函数都必须设置一个基线条件（也就是不在递归的停止点）</li>
</ul>
<p><em>实例</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.confirm(<span class="string">'是否退出递归'</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    recursiveFun()</span><br><span class="line">&#125;</span><br><span class="line">recursiveFun()</span><br></pre></td></tr></table></figure>

<h3 id="计算一个数的阶乘"><a href="#计算一个数的阶乘" class="headerlink" title="计算一个数的阶乘"></a>计算一个数的阶乘</h3><blockquote>
<p>阶乘的概念:  数n的阶乘，定义为<strong>n!</strong>，表示从1到n的整数的乘积。 </p>
<p>(<em>5的阶乘表示为5!，和5×4×3×2×1相等，结果是120, 也就是 (n)x (n -1) x (n-2) x (n -3) x … x 1。</em>)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorialIterative</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 这里循环大于1 是因为每个阶乘最后都会乘1 res默认为1 所以这不乘可以节省一次循环</span></span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        res = res * num</span><br><span class="line">        num--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="comment">/* 思路 </span></span><br><span class="line"><span class="comment">		如： 括号可以理解理解成函数的返回值</span></span><br><span class="line"><span class="comment">		    factorial(3) = 3 * (factorial(2) )</span></span><br><span class="line"><span class="comment">			factorial(3) = 3 * (2 * factorial(1))</span></span><br><span class="line"><span class="comment">			factorial(3) = 3 * (2 * 1)</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归写法说明</strong></p>
<p>在实际应用中每当一个函数被上一个函数调用时，该函数会进入调用栈的顶部。当使用递归的时候，每个函数调用都会堆叠在调用栈的顶部，这是因为每个调用都可能依赖前一个调用的结果。</p>
<blockquote>
<p>从下面两张图可以看出函数执行后以栈的形式排列</p>
</blockquote>
<img src="/2021/11/04/学习JavaScript数据结构与算法/谷歌调用栈.png">

<img src="/2021/11/04/学习JavaScript数据结构与算法/调用栈.png">

<p><strong>js调用栈的大小限制</strong></p>
<p>在浏览器中，如果没有基线条件，递归也不会真正无限地执行下去，在达到一定次数后（每个浏览器次数不一致），会抛出错误</p>
<p><em>如下图谷歌浏览器</em></p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/谷歌栈溢出.png">

<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>斐波那契数列是另一个可以用递归解决的问题。它是一个由0、1、1、2、3、5、8、13、21、34等数组成的序列。数2由1+1得到，数3由1+2得到，数5由2+3得到，以此类推。斐波那契数列的定义如下。</p>
<ul>
<li>位置0的斐波那契数是零。</li>
<li>位置1和2的斐波那契数是1。</li>
<li>n（此处n &gt; 2）的斐波那契数是（n -1）的斐波那契数加上（n -2）的斐波那契数。</li>
</ul>
<blockquote>
<p>下文将介绍用不同的方式求位置为n 的斐波那契数</p>
</blockquote>
<h4 id="迭代求斐波那契数"><a href="#迭代求斐波那契数" class="headerlink" title="迭代求斐波那契数"></a>迭代求斐波那契数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">1</span>, nextNum = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nextNum = num1 + num2</span><br><span class="line">        num1 = num2</span><br><span class="line">        num2 = nextNum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归求斐波那契数"><a href="#递归求斐波那契数" class="headerlink" title="递归求斐波那契数"></a>递归求斐波那契数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(5) = f(4) + f(3) f(4) = f(3) + f(2) f(3) = f(2) + f(1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">// 递归表达式</span></span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n <span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="记忆化斐波那契数"><a href="#记忆化斐波那契数" class="headerlink" title="记忆化斐波那契数"></a>记忆化斐波那契数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上文当中的递归会有重复计算， 所以可以将重复的内容记忆化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 默认缓存 0, 1</span></span><br><span class="line">    <span class="keyword">let</span> meno = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">computed</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (meno[n] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> meno[n]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> meno[n] = computed(n - <span class="number">1</span>) +  computed(n - <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> computed(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么要用递归"><a href="#为什么要用递归" class="headerlink" title="为什么要用递归"></a>为什么要用递归</h4><blockquote>
<p>我们运行一个检测程序来测试本章三种不同的fibonacci函数。<strong>迭代的版本比递归的版本快很多</strong>，所以这表示<strong>递归更慢</strong>。但是，再看看三个不同版本的代码。<strong>递归版本更容易理解，需要的代码通常也更少</strong>。另外，对一些算法来说，迭代的解法可能不可用，而且有了<strong>尾调用优化</strong>，递归的多余消耗甚至可能被消除。所以，我们经常使用递归，因为用它来解决问题会更简单</p>
</blockquote>
<h2 id="第十章-树"><a href="#第十章-树" class="headerlink" title="第十章 树"></a>第十章 树</h2><h3 id="树的相关名词"><a href="#树的相关名词" class="headerlink" title="树的相关名词"></a>树的相关名词</h3><ul>
<li>树（tree）是包含n（n&gt;=0）个节点的有穷集</li>
<li>空集合也是树，称为空树。空树中没有节点。</li>
<li>节点的度：一个节点含有的子树的个数称为该节点的度</li>
<li>树的度：一棵树中，最大的节点的度称为树的度</li>
<li>叶节点或终端节点：度为0的节点称为叶节点；</li>
<li>非终端节点或非叶子节点：度不为0的节点；</li>
<li>双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li>子节点：若A点是B点的父节点，则B是A的子节点</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点</li>
<li>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推</li>
<li>树的高度或深度：树中节点的最大层次；</li>
<li>堂兄弟节点：双亲在同一层的节点互为堂兄弟</li>
<li>节点的祖先：从根到该节点所经分支上的所有节点</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙</li>
<li>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林</li>
</ul>
<h3 id="树的种类："><a href="#树的种类：" class="headerlink" title="树的种类："></a>树的种类：</h3><ul>
<li><p>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树,也称为自由树</p>
</li>
<li><p>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树</p>
</li>
<li><p>二叉树：每个节点最多含有两个子树的树称为二叉树；</p>
<ul>
<li><p>二叉树的性质： n0  = n2 +1 度为0的节点数量是度为2的节点数量加1</p>
</li>
<li><p>二叉树的孩子节点：左孩子为2i右孩子为2i+1 （i指层数）</p>
</li>
<li><p>二叉树第i层(或深度为i)的最大节点数为： 2^i-1^     (i&gt;=1)</p>
</li>
<li><p>二叉树的遍历</p>
<ul>
<li>先(前)序遍历（PreOrderTraversal） ：根节点最先，同级先左后右<ul>
<li>(根节点在开头)</li>
</ul>
</li>
<li>中序遍历(InOrderTraversal) ： 先左后根最后右<ul>
<li>(根节点在中间随机位置)</li>
</ul>
</li>
<li>后序遍历(PostOrderTraversal)  ： 先左后右最后根 <ul>
<li>(根节点在结尾)</li>
<li>注：知道根节点的位置有利于根据给出的遍历，还原二叉树</li>
</ul>
</li>
</ul>
</li>
<li><p>层序遍历：从上到下，从左到右一层层遍历</p>
</li>
<li><p>补充:</p>
</li>
<li><p>深度优先遍历（DFS）: 先中后序遍历</p>
<ul>
<li>通过栈实现</li>
</ul>
</li>
<li><p>广度优先遍历（BFS）:  层序遍历</p>
<ul>
<li>通过队列实现</li>
</ul>







</li>
</ul>
</li>
</ul>
<ul>
<li>满二叉树：除最后一层无任何子节点外，每一层上的所有节点都有两个子节点的二叉树。</li>
</ul>
<h3 id="二叉搜索树（Binary-Search-Tree）"><a href="#二叉搜索树（Binary-Search-Tree）" class="headerlink" title="二叉搜索树（Binary Search Tree）"></a>二叉搜索树（Binary Search Tree）</h3><p>定义：是指一颗空树或具有下列性质的二叉树</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉搜索树；</li>
<li>没有键值相等的节点。</li>
</ol>
<img src="/2021/11/04/学习JavaScript数据结构与算法/二叉搜索树.png">

<ul>
<li>二叉搜索树的实现</li>
<li>时间复杂度：插入，删除，搜索 O(log<del>(n)</del>)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象保存比较状态</span></span><br><span class="line"><span class="keyword">const</span> compare = &#123;</span><br><span class="line">    LESS_THAN: <span class="number">-1</span>,</span><br><span class="line">    BIGGER_THAN: <span class="number">1</span>,</span><br><span class="line">    EQUALS: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a , b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="keyword">return</span> compare.EQUALS</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? compare.LESS_THAN : compare.BIGGER_THAN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(compareFn = defaultCompare)  &#123;</span><br><span class="line">       <span class="keyword">this</span>.root = <span class="literal">undefined</span></span><br><span class="line">       <span class="keyword">this</span>.compareFn = compareFn</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 获取根节点</span></span><br><span class="line">    getRoot() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    insert(key) &#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空则赋值根节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">new</span> Node(key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insertNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.key) === compare.LESS_THAN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> Node(key)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.insertNode(node.left, key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> Node(key)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.insertNode(node.right, key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找是否存在</span></span><br><span class="line">    search(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(<span class="keyword">this</span>.root, key)</span><br><span class="line">    &#125;</span><br><span class="line">    searchNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.key) == compare.LESS_THAN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.left, key)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.key) == compare.BIGGER_THAN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.right, key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找最大</span></span><br><span class="line">    max() &#123;</span><br><span class="line">        <span class="keyword">return</span> maxNode(<span class="keyword">this</span>.root)</span><br><span class="line">    &#125;</span><br><span class="line">    maxNode(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = node</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span> &amp;&amp; current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找最小</span></span><br><span class="line">    min() &#123;</span><br><span class="line">        <span class="keyword">return</span> minNode(<span class="keyword">this</span>.root)</span><br><span class="line">    &#125;</span><br><span class="line">    minNode(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = node</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    preOrderTraverse(callback) &#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrderTraverSeNode(<span class="keyword">this</span>.root, callback)</span><br><span class="line">    &#125;</span><br><span class="line">    preOrderTraverSeNode(node, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            callback(node.key)</span><br><span class="line">            <span class="keyword">this</span>.preOrderTraverSeNode(node.left, callback)</span><br><span class="line">            <span class="keyword">this</span>.preOrderTraverSeNode(node.right, callback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    inOrderTraverse() &#123;</span><br><span class="line">        <span class="keyword">this</span>.inOrderTraverSeNode(<span class="keyword">this</span>.root, callback)</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraverSeNode(node, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.inOrderTraverSeNode(node.left, callback)</span><br><span class="line">            callback(node.key)</span><br><span class="line">            <span class="keyword">this</span>.inOrderTraverSeNode(node.right, callback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    postOrderTraverse() &#123;</span><br><span class="line">        <span class="keyword">this</span>.postOrderTraverSeNode(<span class="keyword">this</span>.root, callback)</span><br><span class="line">    &#125;</span><br><span class="line">    postOrderTraverSeNode(node, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.postOrderTraverSeNode(node.left, callback)</span><br><span class="line">            <span class="keyword">this</span>.postOrderTraverSeNode(node.right, callback)</span><br><span class="line">            callback(node.key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>.removeNode(<span class="keyword">this</span>.root, key)</span><br><span class="line">    &#125;</span><br><span class="line">    removeNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.key) == compare.LESS_THAN) &#123;</span><br><span class="line">            node.left = <span class="keyword">this</span>.removeNode(node.left, key)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.key) == compare.BIGGER_THAN) &#123;</span><br><span class="line">            node.right = <span class="keyword">this</span>.removeNode(node.right, key)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            node = <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node = node.right</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            node = node.left</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> aux = <span class="keyword">this</span>.minNode(node.right)</span><br><span class="line">        node.key = aux.key</span><br><span class="line">        node.right = <span class="keyword">this</span>.removeNode(node.right, aux.key)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树的缺陷：某一边的树深度可能非常的深，数据分布不均匀，如果，一直这样下去，它的搜索效率会越来越低，达到接近链表的O(n).这种情况也称<code>非平衡二叉树</code> </p>
<p>为了保证树的平衡性，树的两边节点个数，深度尽可能相等。可以通过平衡二叉树：AVL 和 红黑树 来实现</p>
<h3 id="AVL树（Adelson-Velskii-Land）"><a href="#AVL树（Adelson-Velskii-Land）" class="headerlink" title="AVL树（Adelson-Velskii-Land）"></a>AVL树（Adelson-Velskii-Land）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p> AVL树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1</p>
<h4 id="高度和平衡因子"><a href="#高度和平衡因子" class="headerlink" title="高度和平衡因子"></a>高度和平衡因子</h4><img src="/2021/11/04/学习JavaScript数据结构与算法/节点的高度.png">

<img src="/2021/11/04/学习JavaScript数据结构与算法/平衡因子.png">



<p><strong>注：</strong> 下文的代码实现中，计算的是左子树与右子树高度差，即（hl-hr），左右均可</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(compareFn = defaultCompare) &#123;</span><br><span class="line">        <span class="keyword">super</span>(compareFn)</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">this</span>.compareFn = compareFn</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取高度</span></span><br><span class="line">    getNodeHeight(node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(getNodeHeight(node.left), getNodeHeight(node.right)) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算平衡因子</span></span><br><span class="line">    getBalanceFactor(node) &#123;</span><br><span class="line">        <span class="keyword">return</span> getNodeHeight(node.left) - getNodeHeight(node.left)</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Left left case: rotate right</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *       b                           a</span></span><br><span class="line"><span class="comment">   *      / \                         / \</span></span><br><span class="line"><span class="comment">   *     a   e -&gt; rotationLL(b) -&gt;   c   b</span></span><br><span class="line"><span class="comment">   *    / \                         /   / \</span></span><br><span class="line"><span class="comment">   *   c   d                       f   d   e</span></span><br><span class="line"><span class="comment">   *  /</span></span><br><span class="line"><span class="comment">   * f</span></span><br><span class="line"><span class="comment">   * @param node Node&lt;T&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    rotationLL(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = node.left</span><br><span class="line">        node.left = tmp.right</span><br><span class="line">        tmp.right = node</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Right right case: rotate left</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *     a                              b</span></span><br><span class="line"><span class="comment">   *    / \                            / \</span></span><br><span class="line"><span class="comment">   *   c   b   -&gt; rotationRR(a) -&gt;    a   e</span></span><br><span class="line"><span class="comment">   *      / \                        / \   \</span></span><br><span class="line"><span class="comment">   *     d   e                      c   d   f</span></span><br><span class="line"><span class="comment">   *          \</span></span><br><span class="line"><span class="comment">   *           f</span></span><br><span class="line"><span class="comment">   * @param node Node&lt;T&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    rotationRR(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = node.right</span><br><span class="line">        node.right = tmp.left</span><br><span class="line">        tmp.left = node</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Left right case: rotate left then right</span></span><br><span class="line"><span class="comment">   *       b                           b                           d</span></span><br><span class="line"><span class="comment">   *      / \                         / \                         / \</span></span><br><span class="line"><span class="comment">   *     a   e -&gt; rotationRR(a) -&gt;   d   e   -&gt; rotationLL(b)    a   b</span></span><br><span class="line"><span class="comment">   *    / \                         / \                         /   / \</span></span><br><span class="line"><span class="comment">   *   c   d                       a   f                       c   f   e</span></span><br><span class="line"><span class="comment">   *        \                     /</span></span><br><span class="line"><span class="comment">   *         f                   c</span></span><br><span class="line"><span class="comment">   * @param node Node&lt;T&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    rotationLR(node) &#123;</span><br><span class="line">        node.left = <span class="keyword">this</span>.rotationRR(node.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rotationLL(node)</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Right left case: rotate right then left</span></span><br><span class="line"><span class="comment">   *     a                              a                           d</span></span><br><span class="line"><span class="comment">   *    / \                            / \                         / \</span></span><br><span class="line"><span class="comment">   *   c   b   -&gt; rotationLL(b) -&gt;    c   d    -&gt; rotationRR(a)   a   b</span></span><br><span class="line"><span class="comment">   *      / \                            / \                     / \   \</span></span><br><span class="line"><span class="comment">   *     d   e                          f   b                   c   f   e</span></span><br><span class="line"><span class="comment">   *    /                                    \</span></span><br><span class="line"><span class="comment">   *   f                                      e</span></span><br><span class="line"><span class="comment">   * @param node Node&lt;T&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    rotaionRL(node) &#123;</span><br><span class="line">        node.right = <span class="keyword">this</span>.rotationLL(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rotationRR(node)</span><br><span class="line">    &#125;</span><br><span class="line">    insert(key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, key)</span><br><span class="line">    &#125;</span><br><span class="line">    insertNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.key) === compare.LESS_THAN) &#123;</span><br><span class="line">            node.left = <span class="keyword">this</span>.insertNode(node.left, key)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.key) === compare.BIGGER_THAN) &#123;</span><br><span class="line">            node.right = <span class="keyword">this</span>.insertNode(node.right, key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> balanceFactor = <span class="keyword">this</span>.getBalanceFactor(node)</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor === <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.left.key) === compare.LESS_THAN) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationLL(node)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationLR(node)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(balanceFactor === <span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.right.key) === compare.BIGGER_THAN) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationRR(node)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationRL(node)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// remove方法完全继承</span></span><br><span class="line">    <span class="comment">// removeNode</span></span><br><span class="line">    removeNode(node, key) &#123;</span><br><span class="line">        node = <span class="keyword">super</span>.removeNode(node, key)</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> balanceFactor = <span class="keyword">this</span>.getBalanceFactor(node)</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor === <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getBalanceFactor(node.left) === <span class="number">0</span> || <span class="keyword">this</span>.getBalanceFactor(node.left) === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationLL(node)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getBalanceFactor(node.left) === <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationLR(node.left)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (balanceFactor === <span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getBalanceFactor(node.right) === <span class="number">0</span> || <span class="keyword">this</span>.getBalanceFactor(node.right) === <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationRR(node)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getBalanceFactor(node.right) === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationRL(node.right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>插入和移除不会旋转</li>
<li>插入删除频率高的情形下红黑树比AVL树更好</li>
</ul>
<h4 id="红黑树的规则"><a href="#红黑树的规则" class="headerlink" title="红黑树的规则"></a>红黑树的规则</h4><ul>
<li>只有红色黑色两种节点组成</li>
<li>根节点是黑色节点</li>
<li>叶节点是为null的黑色节点 （注： 这里的叶节点不是实际存在的节点，它是指在真正叶节点的最后，再加一个虚拟不存在的节点， 并将其涂黑 ）</li>
<li>如果一个节点是红的，那么它的两个子节点都是黑的</li>
<li>不能有两个相邻的红节点，这里的相邻是指 ： 一个红节点不能有红的父节点或子节点；</li>
<li>任意一个节点到叶节点的路径中黑色节点数目相等</li>
</ul>
<p>上述规则保证了：从根到叶子的最长路径，不会超过，最短路径的两倍，从而保证了一定的平衡性</p>
<p>为什么不会超过两倍：根据以上特点，可以得出最短路径是全黑色节点，最长路径，因为红色节点不连续所以最长路径是红色黑色交替的节点</p>
<h4 id="节点的插入"><a href="#节点的插入" class="headerlink" title="节点的插入"></a>节点的插入</h4><p>插入节点时为了不影响原有的规则，我们通常通过变色来达到目的</p>
<ul>
<li><p>变色：</p>
<ul>
<li>插入新节点时，我们最好让默认颜色为红色，因为如果是黑色会导致这条路径上的黑色节点数和其他路径不符，比较难以调整，而红色则不会</li>
<li>红色的缺点：可能发生红红相连的情况，但这种情况相对于黑色的缺点，较为容易解决</li>
</ul>
</li>
</ul>
<h4 id="节点插入时的几种情况"><a href="#节点插入时的几种情况" class="headerlink" title="节点插入时的几种情况"></a>节点插入时的几种情况</h4><p>设插入节点为N ；父节点为P； 其祖父节点为G ； P节点的兄弟节点为U（N节点的叔节点）</p>
<ul>
<li><p>情况一：本身没有节点，插入根节点N,将N变为黑色即可</p>
</li>
<li><p>情况二：父节点P为黑色节点，插入红色节点N时，直接插入，不用改变</p>
</li>
<li><p>情况三：父节点P ，叔节点U为红色节点，祖父节点G为黑色节点</p>
<ul>
<li>插入红色节点N ，将父叔节点改为黑色，祖父节点改为红色</li>
<li>可能出现的问题：祖父节点的父节点也为红色</li>
<li>解决方案：继续向上，依次递归调整颜色，如果最后根节点颜色也被改变，则需要再进行旋转或调整颜色</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树01.png">
</li>
<li><p>情况四：父节点P为红色，祖父节点，叔节点为黑色</p>
<ul>
<li>注：这里的N为左孩子节点</li>
<li>插入红色左孩子节点N，将父节点变为黑色，祖父节点变为红色，之后进行右旋转，将右孩子节点移动到G的左孩子</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树02.png">
</li>
<li><p>情况五：父节点P为红色，祖父节点，叔节点为黑色</p>
<ul>
<li>注：这里的N为右孩子节点</li>
<li>插入右孩子节点N，将树进行左旋转，之后将N变为黑色，G变为红色，进行右旋转</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树03.png">

</li>
</ul>
<p>注：情况四和五，插入的节点都在相对于G节点的左子树，如果是右子树，方法基本相同，无非是旋转方向有一点不同</p>
<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p>注：以下图中的黑色小圈指的是叶子节点null</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树04.png">

<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树05.png">

<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树06.png">

<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树07.png">

<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树08.png">

<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树09.png">

<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedBlackNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key) &#123;</span><br><span class="line">        <span class="keyword">super</span>(key)</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">'red'</span></span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    isRed() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color === <span class="string">'red'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(conmpareFn = defaultCompare) &#123;</span><br><span class="line">        <span class="keyword">super</span>(compareFn)</span><br><span class="line">        <span class="keyword">this</span>.compareFn = compareFn</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    insert(key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">new</span> RedBlackNode(key)</span><br><span class="line">            <span class="keyword">this</span>.root.color = <span class="string">'black'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> newNode = <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, key)</span><br><span class="line">            <span class="keyword">this</span>.ruleTree(newNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    insertNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(node, key) === compare.LESS_THAN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> RedBlackNode(key)</span><br><span class="line">                node.left.parent = node</span><br><span class="line">                <span class="keyword">return</span> node.left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.insertNode(node.left, key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> RedBlackNode(key)</span><br><span class="line">            node.right.parent = node</span><br><span class="line">            <span class="keyword">return</span> node.right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.insertNode(node.right, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ruleTree(node) &#123;</span><br><span class="line">        <span class="keyword">while</span>(node &amp;&amp; node.parent &amp;&amp; node.parent.isRed() &amp;&amp; node.isRed()) &#123;</span><br><span class="line">            <span class="keyword">let</span> parent = node.parent</span><br><span class="line">            <span class="keyword">const</span> grandParent = parent.parent</span><br><span class="line">            <span class="keyword">if</span> (grandParent &amp;&amp; grandParent.left === parent) &#123; <span class="comment">// 父节点是左侧节点</span></span><br><span class="line">                <span class="keyword">const</span> uncle = grandParent.right</span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; uncle.color == <span class="string">'red'</span>) &#123; <span class="comment">// 叔节点也是红色</span></span><br><span class="line">                    grandParent.color = <span class="string">'red'</span></span><br><span class="line">                    parent.color = <span class="string">'black'</span></span><br><span class="line">                    uncle.color = <span class="string">'black'</span></span><br><span class="line">                    node = grandParent</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 叔节点是黑色</span></span><br><span class="line">                    <span class="keyword">if</span> (node === parent.right) &#123; <span class="comment">// 节点是右侧子节点</span></span><br><span class="line">                        <span class="keyword">this</span>.rotationRR(parent)</span><br><span class="line">                        node = parent</span><br><span class="line">                        parent = node.parent</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.rotationLL(grandParent) <span class="comment">// 节点是左侧子节点</span></span><br><span class="line">                    parent.color = <span class="string">'black'</span></span><br><span class="line">                    grandParent.color = <span class="string">'red'</span></span><br><span class="line">                    node = parent</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 父节点是右侧子节点</span></span><br><span class="line">                <span class="keyword">const</span> uncle = grandParent.left</span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; uncle.color === <span class="string">'red'</span>) &#123; <span class="comment">// 叔节点是红色</span></span><br><span class="line">                    grandParent.color = <span class="string">'red'</span></span><br><span class="line">                    parent.color = <span class="string">'black'</span></span><br><span class="line">                    uncle.color = <span class="string">'black'</span></span><br><span class="line">                    node = grandParent</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 节点是左侧子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (node === parent.left) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.rotationLL(parent)</span><br><span class="line">                        node = parent</span><br><span class="line">                        parent = node.parent</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 节点是右侧子节点</span></span><br><span class="line">                    <span class="keyword">this</span>.rotationRR(grandParent)</span><br><span class="line">                    parent.color = <span class="string">'black'</span></span><br><span class="line">                    grandParent.color = <span class="string">'red'</span></span><br><span class="line">                    node = parent</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root.color = <span class="string">'black'</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在插入算法中，使用了右-右旋转和左-左旋转。逻辑和AVL树是一样，但是，由于我们保存了父节点的引用，需要将引用更新为旋转后的新父节点。</span></span><br><span class="line">    <span class="comment">// 更新后代码如下， 所有包含parent行的代码为新代码</span></span><br><span class="line">    </span><br><span class="line">    rotationLL(node) &#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = node.left</span><br><span class="line">        node.left = tmp.right</span><br><span class="line">        <span class="keyword">if</span> (tmp.right &amp;&amp; tmp.right.key) &#123;</span><br><span class="line">            tmp.right.parent = node</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.parent = node.parent</span><br><span class="line">        <span class="keyword">if</span> (!node.parent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = tmp</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node === node.parent.left) &#123;</span><br><span class="line">                node.parent.left = tmp</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.parent.right = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.right = node</span><br><span class="line">        node.parent = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rotationRR(node) &#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = node.right</span><br><span class="line">        node.right = tmp.left</span><br><span class="line">        <span class="keyword">if</span> (tmp.left &amp;&amp; tmp.left.key) &#123;</span><br><span class="line">            tmp.left.parent = node</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.parent = node.parent</span><br><span class="line">        <span class="keyword">if</span> (!node.parent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = tmp</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node === node.parent.left) &#123;</span><br><span class="line">                node.parent.left = tmp</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.parent.right = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.left = node</span><br><span class="line">        node.parent = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对上述代码中父节点是右侧子节点的图示，  父节点是左侧子节点得情况上文已经给出了示意图</p>
<ul>
<li>节点是左侧子节点 (注意： 这里的c1, c2, c3 不是真实节点， 可以理解成上文所指的黑色的null节点)</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树10.png">

<ul>
<li>节点是右侧子节点 (注意： 这里的c1, c2, c3 不是真实节点， 可以理解成上文所指的黑色的null节点)</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/红黑树11.png">

<h2 id="第十一章-二叉堆和堆排序"><a href="#第十一章-二叉堆和堆排序" class="headerlink" title="第十一章 二叉堆和堆排序"></a>第十一章 二叉堆和堆排序</h2><ul>
<li>堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象<ul>
<li>它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。</li>
<li>二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。最大堆大于等于每个它的子节点， 最小堆小于等于每个它的子节点。这叫作堆特性。（<em>二叉搜索树则是，左侧所有子节点都比父节点小，  右侧所有子节点都比父节点大</em>）</li>
</ul>
</li>
<li>二叉堆是计算机科学中一种非常著名的数据结构，由于它能高效、快速地找出最大值和最小值，常被应用于优先队列。它也被用于著名的堆排序算法中。</li>
<li>堆排序的理解</li>
<li>参考资料  <a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/二叉堆.png">

<h3 id="二叉堆数据结构"><a href="#二叉堆数据结构" class="headerlink" title="二叉堆数据结构"></a>二叉堆数据结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换数组位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, a , b</span>) </span>&#123;</span><br><span class="line">    [array[a],array[b]] = [array[b], array[a]]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(compareFn = defaultCompare) &#123;</span><br><span class="line">        <span class="keyword">this</span>.heap = []</span><br><span class="line">        <span class="keyword">this</span>.compareFn = compareFn</span><br><span class="line">    &#125;</span><br><span class="line">    getLeftIndex(idx) &#123;</span><br><span class="line">        <span class="keyword">return</span> idx * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    getRightIndex(idx) &#123;</span><br><span class="line">        <span class="keyword">return</span> idx * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    getParentIndex(idx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx === <span class="number">0</span>) &#123;</span><br><span class="line">            rerturn <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor((idx - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.heap.length</span><br><span class="line">    &#125;</span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.heap.length === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.heap = []</span><br><span class="line">    &#125;</span><br><span class="line">    findMinnum() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isEmpty() ? <span class="literal">undefined</span> : <span class="keyword">this</span>.heap[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    inserted(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.heap.push(value)</span><br><span class="line">            <span class="keyword">this</span>.siftUp(<span class="keyword">this</span>.heap.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上移</span></span><br><span class="line">    siftUp(index) &#123;</span><br><span class="line">        <span class="keyword">let</span> parentIdx = <span class="keyword">this</span>.getParentIndex(index)</span><br><span class="line">        <span class="keyword">while</span>(index &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.compareFn(parentIdx, index) === compare.BIGGER_THAN) &#123;</span><br><span class="line">            swap[<span class="keyword">this</span>.heap, parentIdx, index]</span><br><span class="line">            index = parentIdx</span><br><span class="line">            parentIdx = <span class="keyword">this</span>.getParentIndex(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除最小元素</span></span><br><span class="line">    extract() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size() === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.heap.shift()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存要移除的元素， 方便最后返回</span></span><br><span class="line">        <span class="keyword">const</span> min = <span class="keyword">this</span>.heap[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 将最后一个元素赋值到第一个元素， 相当于 删除第一个元素的同时， 将堆尾的元素移动到堆顶，方便下移</span></span><br><span class="line">        <span class="keyword">this</span>.heap[<span class="number">0</span>] = <span class="keyword">this</span>.heap.pop()</span><br><span class="line">        <span class="keyword">this</span>.siftDown(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> min</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下移</span></span><br><span class="line">    siftDown(index) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = getLeftIndex(index)</span><br><span class="line">        <span class="keyword">let</span> right = getRightIndex(index)</span><br><span class="line">        <span class="keyword">let</span> idx = index</span><br><span class="line">        <span class="keyword">const</span> size = <span class="keyword">this</span>.size()</span><br><span class="line">        <span class="comment">// 分别和左右比较，这里连续两个if 不是if else 是为了取出三个索引中的最小索引</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; compareFn(<span class="keyword">this</span>.heap[idx], <span class="keyword">this</span>.heap[left]) === compare.BIGGER_THAN) &#123;</span><br><span class="line">            idx = left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; compareFn(<span class="keyword">this</span>.heap[idx], <span class="keyword">this</span>.heap[right]) === compare.BIGGER_THAN) &#123;</span><br><span class="line">            idx = right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx !== index) &#123;</span><br><span class="line">            swap(<span class="keyword">this</span>.heap, idx, index)</span><br><span class="line">            <span class="keyword">this</span>.siftDown(idx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 导出数组</span></span><br><span class="line">    getAsArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.heap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆</span></span><br><span class="line"><span class="comment">// 实现大顶堆只需将比较函数翻转</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseCompareFn</span>(<span class="params">compareFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">a, b</span>) =&gt;</span> compareFn(b, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> <span class="keyword">extends</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(compareFn = defaultCompare) &#123;</span><br><span class="line">        surper(ccompareFn)</span><br><span class="line">        <span class="keyword">this</span>.compareFn = reverseCompareFn(compareFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li>特点， 不稳定排序</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处实现使用了堆结构的思想，但并没有直接使用堆实现  (降序排列)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array, compareFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($.isArray.isArray(array)) &#123;</span><br><span class="line">        buildMinHeap(array, compareFn)</span><br><span class="line">        <span class="keyword">let</span> size = array.length</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前最小的值放到数组最后， 之后更新size,再对更新后size长度的数组下移求出当前的小顶堆，之后再次交换，并更新size， 循环至只剩一个元素， 此时的数组就是有序的</span></span><br><span class="line">            swap(array, <span class="number">0</span>, --size) </span><br><span class="line">            siftDown(array, <span class="number">0</span>, array[<span class="number">0</span>], compareFn)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  array</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个小顶堆</span></span><br><span class="line">buildMinHeap() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(array / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 除以2 是因为 另一半作为叶子节点，之后从底部往上进行下移，得出小顶堆</span></span><br><span class="line">        siftDown(array, i, array[i], compareFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// siftDown相当于堆的下移</span></span><br><span class="line">siftDown(array, i, value, compareFn) &#123;</span><br><span class="line">   <span class="keyword">const</span> left = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">   <span class="keyword">const</span> right = i * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">   <span class="keyword">const</span> size = array.length</span><br><span class="line">   <span class="keyword">let</span> index = i</span><br><span class="line">   <span class="keyword">if</span> (left &lt; size &amp;&amp; compareFn(value, array[left]) === compare.BIGGER_THAN) &#123;</span><br><span class="line">       index = left</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; size &amp;&amp; compareFn(value, array[right]) === compare.BIGGER_THAN) &#123;</span><br><span class="line">        index = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index !== i) &#123;</span><br><span class="line">        swap(array, i, index)</span><br><span class="line">        siftDown(array, index, array[index], compareFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十二章-图"><a href="#第十二章-图" class="headerlink" title="第十二章 图"></a>第十二章 图</h2><h3 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h3><p><strong>概念</strong>： 图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）</p>
<p>任何社交网络，例如Facebook、Twitter和Google+，都可以用图来表示。我们还可以使用图来表示道路、航班以及通信，如下图所示</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/图1.png">

<p>一个图<strong>G=(V, E)</strong>由以下元素组成。 V：一组顶点 E：一组边，连接V中的顶点</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/图2.png">

<p><strong>相邻顶点</strong> ： 由一条边连接在一起的顶点。 比如，A和B是相邻的，A和D是相邻的，A和C是相邻的，A和E不是相邻的。</p>
<p><strong>顶点的度</strong>： 一个顶点的度是其相邻顶点的数量。 比如，A和其他三个顶点相连接，因此A的度为3; E和其他两个顶点相连，因此E的度为2。</p>
<p><strong>路径</strong>： 是顶点v 1, v2,…, vk的一个连续序列，其中vi和vi+1是相邻的。以上一示意图中的图为例，其中包含路径A B E I和A C D G。</p>
<p><strong>简单路径</strong>: 简单路径要求不包含重复的顶点。举个例子，A D G是一条简单路径。环也是一个简单路径，比如A D CA（最后一个顶点重新回到A）。</p>
<p><strong>有向图和无向图</strong></p>
<p>图可以是无向的（边没有方向）或是有向的（有向图）。如下图所示，有向图的边有一个方向。</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/有向图.png">

<p><strong>强连通</strong> : 如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D是强连通的，而A和B不是强连通的。</p>
<p><strong>加权图</strong></p>
<p>图还可以是加权的。如下图所示，加权图的边被赋予了权值。</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/加权图.png">

<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><blockquote>
<p> 从数据结构的角度来说，我们有多种方式来表示图。在所有的表示法中，不存在绝对正确的方式。图的正确表示法取决于待解决的问题和图的类型。</p>
</blockquote>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则<code>array[i][j] === 1</code>，否则<code>array[i][j] === 0</code>，如下图所示。</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/邻接矩阵.png">



<p>缺点： 不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点（<strong>注：这里的相邻初衷不是找一个，而是找所有</strong>），即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，而二维数组不太灵活。</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。下面的示意图展示了邻接表数据结构。</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/邻接表.png">

<p>缺点： 对大多数问题来说都是更好的选择， 但是查找两个边是否是相邻顶点的速度不如邻接矩阵快 ， 比如 顶点 v, w, （v索引是 0, w索引是3）， 那么查看<code>arr[0][3]</code>即可（时间复杂度仅为O(1)）</p>
<h4 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h4><p>还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则<code>array[v][e] === 1</code>；否则，<code>array[v][e] === 0</code></p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/关联矩阵.png">

<p>关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存。（补充： 关联矩阵可以展示边的权重）</p>
<h3 id="创建Graph-类"><a href="#创建Graph-类" class="headerlink" title="创建Graph 类"></a>创建Graph 类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(isDirected = false) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vertices = [] <span class="comment">// 保存顶点</span></span><br><span class="line">        <span class="keyword">this</span>.adjList = &#123;&#125; <span class="comment">// 原书中用字典保存， 这里直接使用对象</span></span><br><span class="line">        <span class="keyword">this</span>.isDirected = isDirected <span class="comment">// 是否有向</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加顶点</span></span><br><span class="line">    addVertex(v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.vertices.includes(v)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.vertices.push(v)</span><br><span class="line">            <span class="keyword">this</span>.adjList[v] = []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加边 边连接两个顶点， 所以两个参数为顶点v 顶点w</span></span><br><span class="line">    addEdge(v, w) &#123;</span><br><span class="line">        <span class="comment">// 这里实际上不用if判断直接执行addVertex即可， 且在addVertex方法中 使用 if(!this.adjList[v]) 方式来判断， 同样可以减少复杂度， 而当前写法优势是代码含义更明确（在添加顶点中，判断顶点是否存在， 在添加边中， 判断保存边的数组是否存在）</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.adjList[v]) &#123; </span><br><span class="line">           <span class="keyword">this</span>.addVertex(v)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.adjList[w]) &#123;</span><br><span class="line">           <span class="keyword">this</span>.addVertex(w)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代表v到w有边</span></span><br><span class="line">        <span class="keyword">this</span>.adjList[v].push(w)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isDirected) &#123;</span><br><span class="line">            <span class="comment">// 如果非有向, 那么w到v同样有边</span></span><br><span class="line">            <span class="keyword">this</span>.adjList[w].push(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回顶点列表</span></span><br><span class="line">    getVertices() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.vertices</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回边列表</span></span><br><span class="line">    getAdjList() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.adjList</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例测试 (图与上方邻接表展示的图一致)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> Graph();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myVertices = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class="line">  graph.addVertex(myVertices[i]);</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'B'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'C'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'G'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>, <span class="string">'G'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>, <span class="string">'H'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'E'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'F'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'E'</span>, <span class="string">'I'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>如何访问图所有的节点： 有两种算法可以对图进行遍历：<strong>广度优先搜索（breadth-first search, BFS）</strong>和<strong>深度优先搜索（depth-firstsearch, DFS）</strong></p>
<p>图遍历可以<strong>用来寻找特定的顶点</strong>或<strong>寻找两个顶点之间的路径</strong>，<strong>检查图是否连通</strong>，<strong>检查图是否含有环</strong>，等等</p>
<p>两种算法相似之处：</p>
<ul>
<li><p>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。 </p>
</li>
<li><p>完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。 </p>
</li>
<li><p>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p>
</li>
</ul>
<p>不同之处： </p>
<ul>
<li>深度优先算法，采用栈数据结构，  顶点沿着路径被探索， 存在新的相邻顶点就去访问</li>
<li>广度优先算法，采用队列数据结构， 将顶点存入队列， 最先入队列的顶点先被探索</li>
</ul>
<p>基于上述条件， 使用三种颜色反应顶点状态</p>
<ul>
<li>白色：表示该顶点还没有被访问。</li>
<li>灰色：表示该顶点被访问过，但并未被探索过。</li>
<li>黑色：表示该顶点被访问过且被完全探索过。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义颜色枚举器</span></span><br><span class="line"><span class="keyword">const</span> Colors = &#123;</span><br><span class="line">    WHITE: <span class="number">0</span>,</span><br><span class="line">    GREY: <span class="number">1</span>,</span><br><span class="line">    BLACK: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化颜色函数， 用于初始化所有顶点的颜色</span></span><br><span class="line"><span class="keyword">const</span> initializeColor = <span class="function"><span class="params">vertices</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> color = &#123;&#125;</span><br><span class="line">    vertices.forEach(<span class="function"><span class="params">vertice</span> =&gt;</span> &#123;</span><br><span class="line">        color[vertice] = Colors.WHITE</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><ul>
<li>示意图</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/广度优先搜索.png">



<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> breadthFirstSearch = <span class="function">(<span class="params">graph, startVertice, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vertices = graph.getVertices() <span class="comment">// 获取顶点列表 </span></span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList() <span class="comment">// 获取边列表</span></span><br><span class="line">    <span class="keyword">const</span> colors = initializeColor(vertices) <span class="comment">// 初始化顶点颜色</span></span><br><span class="line">    <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue() <span class="comment">// 创建队列</span></span><br><span class="line">    queue.enqueue(startVertice) <span class="comment">// 将第一个顶点放入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123; <span class="comment">// 队列不为空不停止循环</span></span><br><span class="line">        <span class="keyword">const</span> u = queue.dequeue() <span class="comment">//  将队列当前的第一个顶点移除队列</span></span><br><span class="line">        colors[u] = Colors.GREY <span class="comment">// 颜色置灰色</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adjList[u].length; i++) &#123; <span class="comment">// 边遍历与该顶点有边相连的其他顶点</span></span><br><span class="line">            <span class="comment">// 保存顶点，若是白色，则置为灰色，并将其加入队列</span></span><br><span class="line">            <span class="keyword">const</span> w = adjList[u][i]</span><br><span class="line">            <span class="keyword">if</span> (colors[w] === Colors.WHITE) &#123;</span><br><span class="line">                colors[w] = Colors.GREY</span><br><span class="line">                queue.enqueue(w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完成后， 将顶点置为黑色， 执行回调</span></span><br><span class="line">        colors[u] = Colors.BLACK</span><br><span class="line">        <span class="keyword">if</span> (callback(u)) &#123;</span><br><span class="line">	        callback(u)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BFS的实际应用-（使用BEF寻找最短路径）"><a href="#BFS的实际应用-（使用BEF寻找最短路径）" class="headerlink" title="BFS的实际应用 （使用BEF寻找最短路径）"></a><strong>BFS的实际应用</strong> （<strong>使用BEF寻找最短路径</strong>）</h5><p>上面展示了BFS的实现方式，下面展示他的具体应用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数在完成广度优先遍历的过程中， 返回包含每个顶点前置顶点与每个顶点跟第一个顶点距离的对象</span></span><br><span class="line"><span class="keyword">const</span> BFS = <span class="function">(<span class="params">graph, startVertice</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vertices = graph.getVertices()</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList()</span><br><span class="line">    <span class="keyword">const</span> distances = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> predecessors = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> colors = initializeColors(vertices)</span><br><span class="line">    <span class="comment">// 初始化所有顶点距离和前置顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">	    distances[vertices[i]] = <span class="number">0</span></span><br><span class="line">        predecessors[vertices[i]] = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line">    queue.enqueue(startVertice)</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">const</span> u = queue.dequeue()</span><br><span class="line">        colors[u] = Colors.GREY</span><br><span class="line">        <span class="keyword">if</span> (i = <span class="number">0</span>; i &lt; adjList[u].length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> w = adjList[u][i]</span><br><span class="line">            <span class="keyword">if</span> (colors[w] === Colors.WHITE) &#123;</span><br><span class="line">                colors[w] = Colors.GREY</span><br><span class="line">                <span class="comment">// 距离更新, 当前顶点据startVertice的距离等于其前置顶点距startVertice顶点的距离加1</span></span><br><span class="line">                distances[w] = distances[u] + <span class="number">1</span> </span><br><span class="line">                predecessors[w] = u <span class="comment">// 前置顶点更新</span></span><br><span class="line">                queue.enqueue(w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[u] = Colors.BLACK</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        distances,</span><br><span class="line">        predecessors</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过上述返回值， 可以求出最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 BFS函数, 保存返回值</span></span><br><span class="line"><span class="comment">// const myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']; 这里图使用上方创建的图， 所以第一个顶点是myVertices[0]</span></span><br><span class="line"><span class="keyword">const</span> shortestPath = BFS(graph, myVertices[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 保存开始顶点</span></span><br><span class="line"><span class="keyword">const</span> fromVertice = myVertices[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//遍历其他顶点， 最终目的是打印， 开始顶点到任意其他顶点的路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> toVertice = myVertices[i]</span><br><span class="line">    <span class="keyword">const</span> path = <span class="keyword">new</span> Stack()</span><br><span class="line">    <span class="comment">// 将当前顶点赋值为i， push到栈中， 之后通过前置顶点更新赋值， 到前置顶点为开始顶点时结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = toVertice; i !== fromVertice; i = shortestPath.predecessors[i]) &#123;</span><br><span class="line">        path.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将开始顶点加入栈</span></span><br><span class="line">    path.push(fromVertice)</span><br><span class="line">    <span class="comment">// 后进新出， 从而求出当前路径</span></span><br><span class="line">    <span class="keyword">let</span> s = path.pop()</span><br><span class="line">    <span class="keyword">while</span>(!path.isEmpty) &#123;</span><br><span class="line">        s += <span class="string">'-'</span> + path.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><ul>
<li><strong>示意图</strong></li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/深度优先.png">

<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h5><img src="/2021/11/04/学习JavaScript数据结构与算法/深度优先具体流程.png">

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">depthFirstSearch</span>(<span class="params">graph, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vertices = graph.getVertices()</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList()</span><br><span class="line">    <span class="keyword">const</span> colors = initializeColor(vertices)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[vertices[i]] === Colors.WHITE) &#123;</span><br><span class="line">            depthFirstSearchVisit(vertices[i], colors, adjList, callback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">depthFirstSearchVisit</span>(<span class="params">vertice, colors, adjList, callback</span>) </span>&#123;</span><br><span class="line">    colors[vertice] = Colors.GREY</span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        callback(vertice)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; adjList[vertice].length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> w = adjList[vertice][i]</span><br><span class="line">        <span class="keyword">if</span> (colors[w] === Colors.WHITE) &#123;</span><br><span class="line">            depthFirstSearchVisit(w, colors, adjList, callback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    colors[vertice] = Colors.BLACK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="DFS算法改造"><a href="#DFS算法改造" class="headerlink" title="DFS算法改造"></a><strong>DFS算法改造</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在原有深度优先遍历过程中， 保存顶点发现时间d[v] 顶点完成探索变为黑色的结束时间f[v]， 以及顶点的前置顶点p[v]</span></span><br><span class="line"><span class="comment">// time = &#123;num: 0&#125; ,用于计数， 没有直接用常量是为了引用类型才能保证传值过程中， 值不变</span></span><br><span class="line"><span class="keyword">const</span> DFS = <span class="function">(<span class="params">graph, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vertices = graph.getVertices()</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList()</span><br><span class="line">    <span class="keyword">const</span> colors = initializeColor(vertices)</span><br><span class="line">    <span class="keyword">const</span> d = &#123;&#125;, f = &#123;&#125;, p = &#123;&#125;, time = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; vertices.length; i++) &#123;</span><br><span class="line">        d[vertices[i]] = <span class="number">0</span></span><br><span class="line">        f[vertices[i]] = <span class="number">0</span></span><br><span class="line">        p[vertices[i]] = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[vertices[i]] === Colors.WHITE) &#123;</span><br><span class="line">            DFSVisit(vertices[i], d, f, p, time, colors, adjList, callback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        discovery: d,</span><br><span class="line">        finished: f,</span><br><span class="line">        predecessors: p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DFSVisit = <span class="function">(<span class="params">vertice, d, f, p, time, colors, adjList, callback</span>)  =&gt;</span> &#123;</span><br><span class="line">    colors[vertice] = Colors.GREY</span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        callback()</span><br><span class="line">    &#125;</span><br><span class="line">    d[vertice] = ++time.num</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; adjList[vertice].length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> w = adjList[vertice][i]</span><br><span class="line">        <span class="keyword">if</span> (colors[w] === Colors.WHITE) &#123;</span><br><span class="line">            p[w] = vertice</span><br><span class="line">            DFSVisit(w, d, f, p, time, colors, adjList, callback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    colors[vertice] = Colors.BLACK</span><br><span class="line">    f[vertice] = ++time.num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于改进过的深度优先搜索，有两点需要我们注意：</p>
<blockquote>
<p> 时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；</p>
<p> 对于所有的顶点u, d[u]&lt;f[u]（意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了）。</p>
</blockquote>
<p>基于这两点得出结论</p>
<blockquote>
<p>1 &lt;= d[v] &lt; f[v] &lt;= 2|v|</p>
</blockquote>
<p>如果对同一个图使用新得深度优先搜索方法， 可以得到如下信息  <em>(发现时间 / 探索时间)</em></p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/深度优先2.png">

<h5 id="DFS改造后的实际应用-（实现拓扑排序）"><a href="#DFS改造后的实际应用-（实现拓扑排序）" class="headerlink" title="DFS改造后的实际应用 （实现拓扑排序）"></a><strong>DFS改造后的实际应用</strong> （<strong>实现拓扑排序</strong>）</h5><p><strong>拓扑排序</strong>：  当我们需要编排一些任务或步骤的执行顺序时，这称为拓扑排序（topologicalsorting，英文亦写作topsort或是toposort），排序的图要求是一个 <strong>有向无环图（DAG）</strong></p>
<blockquote>
<p>在日常生活中，这个问题在不同情形下都会出现。例如，当我们开始学习一门计算机科学课程，在学习某些知识之前得按顺序完成一些知识储备（你不可以在上算法I课程前先上算法II课程）。当我们在开发一个项目时，需要按顺序执行一些步骤。例如，首先从客户那里得到需求，接着开发客户要求的东西，最后交付项目。你不能先交付项目再去收集需求</p>
</blockquote>
<img src="/2021/11/04/学习JavaScript数据结构与算法/有向无环图.png">

<p>创建图, 并执行深度优先搜索</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> Graph(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> myVertices = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class="line">    graph.addVertex(myVertices[i])</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'C'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'D'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'F'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'F'</span>, <span class="string">'E'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'D'</span>)</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'E'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = DFS(graph)</span><br></pre></td></tr></table></figure>

<ul>
<li>执行上述代码后， 图的发现和完成时间如下</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/拓扑排序.png">

<ul>
<li>接下来以倒序的方式排序完成时间数组， 从而得出图的拓扑排序</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> topSort = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> max = <span class="number">0</span>, maxName = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; myVertices.length; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> vertice = myVertices[j]</span><br><span class="line">            <span class="keyword">const</span> finished = result.finished[vertice]</span><br><span class="line">            <span class="keyword">if</span> (finished &gt; max) &#123;</span><br><span class="line">                max = finished</span><br><span class="line">                maxName = vertice</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="string">'-'</span> + maxName</span><br><span class="line">        <span class="comment">// 这里直接删除finished中对应的值， 来达到每次迭代去掉最大值的目的</span></span><br><span class="line">        <span class="keyword">delete</span> result.finished[maxName]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line">topSort() <span class="comment">//  -B-A-D-C-F-E</span></span><br></pre></td></tr></table></figure>

<h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><p>求有向图中 顶点A到其余顶点之间的 最短路径</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/最短路径.png">

<p>声明对应的邻接矩阵</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="Dijkstra（狄克斯特拉）算法"><a href="#Dijkstra（狄克斯特拉）算法" class="headerlink" title="Dijkstra（狄克斯特拉）算法"></a>Dijkstra（狄克斯特拉）算法</h4><ul>
<li>Dijkstra算法是一种计算从单个源到所有其他源的最短路径的贪心算法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求src位置顶点 到其余顶点最短路径, 这里的graph 是邻接矩阵</span></span><br><span class="line"><span class="keyword">const</span> dijkstra = <span class="function">(<span class="params">graph, src</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dist 保存位置 visited 保存是否访问过该行</span></span><br><span class="line">    <span class="keyword">const</span> dist = [], visited = []</span><br><span class="line">    <span class="keyword">const</span> &#123;length&#125; = graph</span><br><span class="line">    <span class="comment">// 初始化dist visited</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        dist[i] = <span class="literal">Infinity</span></span><br><span class="line">        visited[i] = <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line">    dist[src] = [<span class="number">0</span>]  <span class="comment">// src自身距离为0</span></span><br><span class="line">    <span class="comment">// length - 1 是因为路径只需要累计到length - 1即可， 最后一层无论是否有值， 都不需要累计</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">const</span> u = minDistance(dist, visited) <span class="comment">// 求出当前 dist中 暂未访问的最短路径</span></span><br><span class="line">        visited[u] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] === <span class="literal">false</span> </span><br><span class="line">                &amp;&amp; graph[u][v] !== <span class="number">0</span> </span><br><span class="line">                &amp;&amp; dist[u] !== <span class="literal">Infinity</span> </span><br><span class="line">                &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = graph[u][v] + dist[u]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> minDistance = <span class="function">(<span class="params">dist, visited</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="literal">Infinity</span>, minIdx = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dist.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] === <span class="literal">false</span> &amp;&amp; dist[i] &lt;= min) &#123;</span><br><span class="line">            min = dist[i]</span><br><span class="line">            minIdx = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minIdx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>验证</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dijkstra(graph, <span class="number">0</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">3 6</span></span><br><span class="line"><span class="comment">4 4 </span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="Floyd-Warshall-弗洛伊德-算法"><a href="#Floyd-Warshall-弗洛伊德-算法" class="headerlink" title="Floyd-Warshall(弗洛伊德)算法"></a>Floyd-Warshall(弗洛伊德)算法</h4><ul>
<li>状态转移方程</li>
</ul>
<blockquote>
<p><strong>map[i,j] = min{map[i,k]+map[k,j],map[i,j]}</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">floydWarshall</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注： dist 相当于换一种规则保存邻接矩阵graph  顶点到自身的距离存为0 , 顶点没有边 存为Infinity ， 其余情况（有权值）直接保存</span></span><br><span class="line">    <span class="comment">// 初始化得到数组 </span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    const dist = [</span></span><br><span class="line"><span class="comment">        [0,        2,        4,        Infinity, Infinity, Infinity],</span></span><br><span class="line"><span class="comment">        [Infinity, 0,        2,        4,        2,        Infinity],</span></span><br><span class="line"><span class="comment">        [Infinity, Infinity, 0,        Infinity, 3,        Infinity],</span></span><br><span class="line"><span class="comment">        [Infinity, Infinity, Infinity, 0,        Infinity, 2],</span></span><br><span class="line"><span class="comment">        [Infinity, Infinity, Infinity, 3,        0,        2],</span></span><br><span class="line"><span class="comment">        [Infinity, Infinity, Infinity, Infinity, Infinity, 0]</span></span><br><span class="line"><span class="comment">	]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> dist = [], &#123;length&#125; = graph</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        dist[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                dist[i][j] = <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isFinite</span>(graph[i][j])) &#123;</span><br><span class="line">                dist[i][j] = <span class="literal">Infinity</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dist[i][j] = graph[i][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; length; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行完毕后返回值</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">        [<span class="number">0</span>,        <span class="number">2</span>,        <span class="number">4</span>,        <span class="number">6</span>,        <span class="number">4</span>,        <span class="number">6</span>],</span><br><span class="line">        [<span class="literal">Infinity</span>, <span class="number">0</span>,        <span class="number">2</span>,        <span class="number">4</span>,        <span class="number">2</span>,        <span class="number">4</span>],</span><br><span class="line">        [<span class="literal">Infinity</span>, <span class="literal">Infinity</span>, <span class="number">0</span>,        <span class="number">6</span>,        <span class="number">3</span>,        <span class="number">5</span>],</span><br><span class="line">        [<span class="literal">Infinity</span>, <span class="literal">Infinity</span>, <span class="literal">Infinity</span>, <span class="number">0</span>,        <span class="literal">Infinity</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="literal">Infinity</span>, <span class="literal">Infinity</span>, <span class="literal">Infinity</span>, <span class="number">3</span>,        <span class="number">0</span>,        <span class="number">2</span>],</span><br><span class="line">        [<span class="literal">Infinity</span>, <span class="literal">Infinity</span>, <span class="literal">Infinity</span>, <span class="literal">Infinity</span>, <span class="literal">Infinity</span>, <span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>最小生成树（MST）问题是网络设计中常见的问题。想象一下，你的公司有几间办公室，要以最低的成本实现办公室电话线路相互连通，以节省资金，最好的办法是什么？这也可以应用于岛桥问题。设想你要在n个岛屿之间建造桥梁，想用最低的成本实现所有岛屿相互连通。这两个问题都可以用MST算法来解决，其中的办公室或者岛屿可以表示为图中的一个顶点，边代表成本。下面有一个图的例子，其中较粗的边是一个MST的解决方案</p>
<p>MST的特点：</p>
<ul>
<li>因为是树， 所以不能有环</li>
<li>边必须连接全部顶点， 也就是边的数量是顶点数量减一</li>
<li>因为最小， 所以权值最小</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/mst.png">

<p>本节我们将学习两种主要的求最小生成树的算法：<strong>Prim算法和Kruskal算法</strong> 。(<strong>求解加权无向连通图的MST问题的贪心算法</strong>)</p>
<h4 id="Prim-普里姆-算法"><a href="#Prim-普里姆-算法" class="headerlink" title="Prim(普里姆)算法"></a>Prim(普里姆)算法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 dijkstra 算法流程类似 ，区别在于 多了保存 路径的parent数组 ,且if判断条件变为 保存权值最小的边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prim = <span class="function"><span class="params">graph</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> visited = [], parent = [], key = [], &#123; length &#125; = graph</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span></span><br><span class="line">        key[i] = <span class="literal">Infinity</span></span><br><span class="line">    &#125;</span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> u = minKey(key, visited)</span><br><span class="line">        visited[u] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[u][v] &amp;&amp; !visited[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class="line">                key[v] = graph[u][v]</span><br><span class="line">                parent[v] = u</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minKey</span>(<span class="params">key, visited</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="literal">Infinity</span>, minIdx = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; key.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] === <span class="literal">false</span> &amp;&amp; key[i] &lt;= min) &#123;</span><br><span class="line">            min = key[i]</span><br><span class="line">            minIdx = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minIdx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义graph</span></span><br><span class="line"><span class="keyword">const</span> graph = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 执行算法</span></span><br><span class="line"><span class="keyword">const</span> parent = prim(graph)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 parent</span></span><br><span class="line"><span class="comment">// [-1, 0, 1, 5, 1, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历parent</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Edge   Weight'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(parent[i] + <span class="string">' - '</span> + i + <span class="string">'   '</span> + graph[i][parent[i]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印如下信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Edge Weight</span></span><br><span class="line"><span class="comment">0-1  2</span></span><br><span class="line"><span class="comment">1-2  2</span></span><br><span class="line"><span class="comment">5-3  2</span></span><br><span class="line"><span class="comment">1-4  2</span></span><br><span class="line"><span class="comment">4-5  2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="Kruskal-克鲁斯卡尔-算法"><a href="#Kruskal-克鲁斯卡尔-算法" class="headerlink" title="Kruskal(克鲁斯卡尔)算法"></a>Kruskal(克鲁斯卡尔)算法</h4><ul>
<li><p>克鲁斯卡尔算法是求连通网的最小生成树的另一种方法。与普里姆算法不同，它的时间复杂度为O（eloge）（e为网中的边数），所以，适合于求边稀疏的网的最小生成树</p>
</li>
<li><p><strong>Kruskal算法与Prim算法的不同之处在于，Kruskal在找最小生成树结点之前，需要对所有权重边做从小到大排序。</strong>将排序好的权重边依次加入到最小生成树中，如果加入时产生回路就跳过这条边，加入下一条边。当所有结点都加入到最小生成树中之后，就找出了最小生成树。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 书中kruskal算法最终结果有误， 这里使用另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEdges</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dist = [], edge = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; graph.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dist.push(graph[i][j]) <span class="comment">// 存权值</span></span><br><span class="line">                edge.push([i, j]) <span class="comment">// 存顶点</span></span><br><span class="line">                <span class="comment">// 保存i,j后,因为是无向图,为了防止后续循环重复保存将 j, i  置为0 </span></span><br><span class="line">                graph[j][i] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dist,</span><br><span class="line">        edge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">edgeSortFun</span>(<span class="params">getEdge</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;dist, edge&#125; = getEdge</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dist.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; dist.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                [dist[j], dist[j+<span class="number">1</span>]] = [dist[j+<span class="number">1</span>], dist[j]]</span><br><span class="line">                <span class="comment">// 注意： 该写法连续使用时， 一定要在这里加上分号， 否则他会与上一行当做同一行代码执行，导致结果出错</span></span><br><span class="line">                ;[edge[j], edge[j+<span class="number">1</span>]] = [edge[j+<span class="number">1</span>], edge[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">i, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[i]) &#123;</span><br><span class="line">        i = parent[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span> (<span class="params">i, j, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i !== j) &#123;</span><br><span class="line">        parent[j] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kruskal = <span class="function">(<span class="params">graph</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 保存距离dist 和 边 edge, 注意这里会对原graph的值造成影响， 如果不想改变值， 可以在函数内定义一个保存graph的新数组使用</span></span><br><span class="line">    <span class="keyword">const</span> getEdge = getEdges(graph)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用冒泡排序对得到的边进行排序</span></span><br><span class="line">    <span class="keyword">const</span> edgeSort = edgeSortFun(getEdge)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存结果的数组</span></span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="comment">// 保存并查集</span></span><br><span class="line">    <span class="keyword">const</span> parent = []</span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span> <span class="comment">// 用于从edgeSort 中获得边</span></span><br><span class="line">    <span class="comment">// 边数量等于顶点数量减一</span></span><br><span class="line">    <span class="keyword">while</span> (result.length &lt; graph.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> v = edgeSort[k]</span><br><span class="line">        <span class="comment">// find  得到顶点的终点 union  判断终点是否相等， 这种方式称为并查集</span></span><br><span class="line">        <span class="keyword">const</span> i = find(v[<span class="number">0</span>], parent)</span><br><span class="line">        <span class="keyword">const</span> j = find(v[<span class="number">1</span>], parent)</span><br><span class="line">        <span class="keyword">if</span> (union(i, j, parent)) &#123;</span><br><span class="line">            result.push(v)</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十三章-排序和搜索算法"><a href="#第十三章-排序和搜索算法" class="headerlink" title="第十三章 排序和搜索算法"></a>第十三章 排序和搜索算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>对未排序的元素，从头到尾依次比较相邻两个元素大小关系，如果左边大（或者小），则交换位置，当换到最右边时，继续从左边开始，这次换到倒数第二个位置即可，如此往复，直到排序完成</li>
</ul>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//解构得到arr的length属性</span></span><br><span class="line">  <span class="keyword">const</span> &#123;length&#125; = arr</span><br><span class="line">  <span class="comment">//外层循环为比较轮数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//内层循环为比较次数 一次内循环结束，就会有一个大值排到后面</span></span><br><span class="line">    <span class="comment">// -i是避免对已经排序过的数字重复比较，减少比较次数，提高效率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;length<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[j],arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>],arr[j]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间复杂度的计算"><a href="#时间复杂度的计算" class="headerlink" title="时间复杂度的计算"></a>时间复杂度的计算</h4><p>随机使用一组数字，可以得到如果所示的排序次数</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/冒泡排序.png">

<p>那么可以得出如果有n个数字，排序总次数为，(n-1+n-2+ ·····1) =  n(n-1) / 2</p>
<p>又∵ n(n-1) / 2 -&gt; n^2^ - n    -&gt;   n^2^ 所以 冒泡排序的时间复杂度为 O(n^2^)</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p>
<img src="/2021/11/04/学习JavaScript数据结构与算法/选择排序.gif">

<ul>
<li>选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。</li>
</ul>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;length&#125; = arr</span><br><span class="line">  <span class="comment">//从0开始循环 一直循环到length-2的位置为止</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//定义一个min用于记录最小的位置</span></span><br><span class="line">    <span class="keyword">let</span> min = i</span><br><span class="line">    <span class="comment">// i+1 是为了排除已经排序过得最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j= i+<span class="number">1</span>; j&lt;length; j++) &#123;</span><br><span class="line">      <span class="comment">// 将其余位置进行依次比较，如果最小值发生变化则记录下来</span></span><br><span class="line">      <span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">        min = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将比较后的最小值与开头的位置i进行交换 之后继续循环</span></span><br><span class="line">    [arr[i],arr[min]] = [arr[min],arr[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序的效率"><a href="#选择排序的效率" class="headerlink" title="选择排序的效率"></a>选择排序的效率</h4><ul>
<li>比较次数相同，所以时间复杂度相同都是O(n^2^)</li>
</ul>
<h4 id="选择排序与冒泡排序的区别"><a href="#选择排序与冒泡排序的区别" class="headerlink" title="选择排序与冒泡排序的区别"></a>选择排序与冒泡排序的区别</h4><ul>
<li>两者的时间复杂度相同都是O(n^2^)</li>
<li>但通常来说，选择排序的速度更快些</li>
<li>两者的区别主要体现在交换次数上：<ul>
<li>两者每一轮都是通过比较将最大或最小值放到指定位置，就这一点来说，比较次数是相同的</li>
<li>然而在比较过程中，冒泡排序是，两两比较，一旦符合要求就交换。选择排序是，只记下最小或最大值的位置，在最后才交换，它的交换次数更少，所以相对更快些</li>
</ul>
</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul>
<li>构建有序的序列。</li>
<li>对于未排序的数据，在已排序数据中，从后向前扫描，找到相应位置插入</li>
</ul>


<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//解构取出数组长度</span></span><br><span class="line">  <span class="keyword">const</span> &#123;length&#125; = arr</span><br><span class="line">  <span class="comment">//遍历除第0个元素外的所有元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;length; i++) &#123;</span><br><span class="line">    <span class="comment">//因为while循环需要从后向前比较，所以需要一个可变的索引值</span></span><br><span class="line">    <span class="comment">//保存当前遍历元素的索引到j</span></span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    <span class="comment">//因为之后arr[i]得值可能发生改变</span></span><br><span class="line">    <span class="comment">//所以保存当前元素索引对应的值到temp</span></span><br><span class="line">    <span class="keyword">const</span> temp = arr[i]</span><br><span class="line">    <span class="comment">//将temp与它前面的已排序序列进行比较 如果符合大于temp 且j&gt;0时</span></span><br><span class="line">    <span class="keyword">while</span> (arr[j<span class="number">-1</span>] &gt; temp &amp;&amp; j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//将前值赋予后值</span></span><br><span class="line">      arr[j] = arr[j<span class="number">-1</span>]</span><br><span class="line">      <span class="comment">//通过自减j的值，改变对比的值</span></span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后将temp中保存的值 赋予对应的空位</span></span><br><span class="line">    arr[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序的效率"><a href="#插入排序的效率" class="headerlink" title="插入排序的效率"></a>插入排序的效率</h4><p>最坏时间复杂度：每一次都扫描到最前面才找到合适位置</p>
<p> 1+2+3···n-1 = n(n-1) / 2       ==O(n^2^)==</p>
<p>平均时间复杂度：一般来说扫描到一半即可找到合适位置，虽然复杂度没有变化，但由于多除了2实际上是有效率提升的</p>
<p> 1+2+3···n-1 = n(n-1) / 2/2 =   n(n-1) / 4      ==O(n^2^)==</p>
<p>最优时间复杂度：数据原本就有序每次直接就可以找到   ==O(n)==</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul>
<li>归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/归并排序.png">

<h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;length&#125;  = array</span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> left = mergeSort(array.slice(<span class="number">0</span>, gap))</span><br><span class="line">        <span class="keyword">const</span> right = mergeSort(array.slice(gap, length))</span><br><span class="line">        array = merge(left, right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">        res.push(left[i] &lt; right[j] ? left[i++] : right[j++])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.concat(i &lt; left.length ? left.slice(i) : right.slice(j))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul>
<li>也称递减增量排序算法<ul>
<li>（设定一个增量，将元素划为符合增量的区域，之后逐次递减至1 ）</li>
<li>增量的取值<ul>
<li>排序创始者建议 n/2 直到取到1 为止</li>
<li>目前最好的取法可从如下链接自行查看：</li>
<li><a href="https://zh.wikipedia.org/wiki/希尔排序" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F</a></li>
</ul>
</li>
</ul>
</li>
<li>希尔排序是基于插入排序的改进版，是非稳定排序算法</li>
<li>插入排序低效的原因：每次只能将数据移动一位</li>
<li>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/希尔排序.png">

<h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//解构取出数组长度</span></span><br><span class="line">  <span class="keyword">const</span> &#123;length&#125; = arr</span><br><span class="line">  <span class="comment">//设定初始增量</span></span><br><span class="line">  <span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>)</span><br><span class="line">  <span class="comment">//增量必须大于才可以进行下一步</span></span><br><span class="line">  <span class="keyword">while</span>(gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//从增量开始向后遍历元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=gap; i&lt;length; i++) &#123;</span><br><span class="line">      <span class="comment">//保存当前遍历元素的索引到j</span></span><br><span class="line">      <span class="keyword">let</span> j = i</span><br><span class="line">      <span class="comment">//保存当前元素索引对应的值到temp</span></span><br><span class="line">      <span class="keyword">const</span> temp = arr[i]</span><br><span class="line">      <span class="comment">//这里的处理方式类似插入排序</span></span><br><span class="line">      <span class="comment">// 注意这里的while循环条件必须写temp不能写arr[i] 因为arr[i]值会变化</span></span><br><span class="line">      <span class="keyword">while</span> (arr[j-gap] &gt; temp &amp;&amp; j &gt; gap<span class="number">-1</span>) &#123;</span><br><span class="line">        arr[j] = arr[j-gap]</span><br><span class="line">        j -= gap</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减少增量，重新开始新一轮遍历</span></span><br><span class="line">    gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序的效率"><a href="#希尔排序的效率" class="headerlink" title="希尔排序的效率"></a>希尔排序的效率</h4><ul>
<li>希尔排序的效率是和增量息息相关的</li>
<li>一个好的增量能够显著提升希尔排序效率，如上文链接中提到的最好取法，甚至在小数组中，排序速度比快速排序和堆排序还快（只限小数组，大数组还是快速排序快）</li>
<li>而通常来说 类似 n/ 2这样的大多数取法，速度也都是比O(n^2^)类算法要快的</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ul>
<li>快速排序也许是最常用的排序算法了。它的复杂度为O(nlog(n))，且性能通常比其他复杂度为O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）</li>
<li>步骤<ul>
<li>(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。</li>
<li>(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。</li>
<li>(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。</li>
</ul>
</li>
</ul>
<h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> quick(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = partition(arr, left, right)</span><br><span class="line">        <span class="keyword">if</span> (index - <span class="number">1</span> &gt; left) &#123;</span><br><span class="line">            quick(arr, left, index - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; right) &#123;</span><br><span class="line">            quick(arr, index, right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pivod = arr[<span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">let</span> i = left, j = right</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; pivod) &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; pivod) &#123;</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">            [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class="line">            i++</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ul>
<li>计数排序是我们在本书中学习的第一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。</li>
<li>计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组。它是用来排序整数的优秀算法（它是一个<strong>整数排序算法</strong>），时间复杂度为O(n+k)，其中k是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。</li>
</ul>
<h4 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="built_in">Array</span>(max + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[count++] = j</span><br><span class="line">            bucket[j]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ul>
<li>桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。</li>
</ul>
<h4 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">arr, bucketSize = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取划分完毕的桶</span></span><br><span class="line">    <span class="keyword">const</span> buckets = createBuckets(arr, bucketSize)</span><br><span class="line">    <span class="comment">// 使用插入排序对桶内值进行排序， 并返回最终结果</span></span><br><span class="line">    <span class="keyword">return</span> sortBucket(buckets)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBuckets</span>(<span class="params">arr, bucketSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line">    <span class="keyword">const</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, arr)</span><br><span class="line">    <span class="keyword">const</span> buckets = []</span><br><span class="line">    <span class="comment">// 通过最大最小值与桶内元素值， 得出需要创建的桶数量, 加1 保证最少有一个桶</span></span><br><span class="line">    <span class="keyword">const</span> bucketCount = <span class="built_in">Math</span>.floor((max - min) / bucketSize) + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        buckets[i] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 求出元素应该放置的桶</span></span><br><span class="line">        <span class="keyword">const</span> index = <span class="built_in">Math</span>.floor((arr[j] - min) / bucketSize)</span><br><span class="line">        <span class="comment">// 将元素放入指定桶</span></span><br><span class="line">        buckets[index].push(arr[j])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buckets</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortBucket</span>(<span class="params">buckets</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i])</span><br><span class="line">        res.push(...buckets[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ul>
<li><p>基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。比如，对于十进制数，使用的基数是10。因此，算法将会使用10个桶用来分布元素并且首先基于个位数字进行排序，然后基于十位数字，然后基于百位数字，以此类推。</p>
</li>
<li><p>基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>
</li>
<li><p>假设有一串数组如下</p>
<ul>
<li><p>73, 22, 93, 43, 55, 14, 28, 65, 39, 81</p>
</li>
<li><p>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">81</span></span><br><span class="line"><span class="number">2</span> <span class="number">22</span></span><br><span class="line"><span class="number">3</span> <span class="number">73</span> <span class="number">93</span> <span class="number">43</span></span><br><span class="line"><span class="number">4</span> <span class="number">14</span></span><br><span class="line"><span class="number">5</span> <span class="number">55</span> <span class="number">65</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> <span class="number">28</span></span><br><span class="line"><span class="number">9</span> <span class="number">39</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来将这些桶子中的数值重新串接起来，成为以下的数列：</p>
</li>
<li><p>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p>
</li>
<li><p>接着再进行一次分配，这次是根据十位数来分配：</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">14</span></span><br><span class="line"><span class="number">2</span> <span class="number">22</span> <span class="number">28</span></span><br><span class="line"><span class="number">3</span> <span class="number">39</span></span><br><span class="line"><span class="number">4</span> <span class="number">43</span></span><br><span class="line"><span class="number">5</span> <span class="number">55</span></span><br><span class="line"><span class="number">6</span> <span class="number">65</span></span><br><span class="line"><span class="number">7</span> <span class="number">73</span></span><br><span class="line"><span class="number">8</span> <span class="number">81</span></span><br><span class="line"><span class="number">9</span> <span class="number">93</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来将这些桶子中的数值重新串接起来，成为以下的数列：</p>
</li>
<li><p>14, 22, 28, 39, 43, 55, 65, 73, 81, 93</p>
</li>
<li><p>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止</p>
</li>
</ul>
</li>
</ul>
<h4 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, radixBase = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, arr)</span><br><span class="line">    <span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line">    <span class="keyword">let</span> digit = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 这里while的判断条件使用最大最小值差值再除， 能够减少while循环次数</span></span><br><span class="line">    <span class="keyword">while</span> ((max - min) / digit &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 求每个进制位排序结果， 个位， 十位， 百位...</span></span><br><span class="line">        arr = radixFun(arr, radixBase, digit, min)</span><br><span class="line">        digit *= radixBase</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixFun</span>(<span class="params">arr, radixBase, digit, min</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> aux = [], buckets = []</span><br><span class="line">    <span class="keyword">let</span> bucketIndex</span><br><span class="line">    <span class="comment">// 根据进制初始化位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; radixBase; i++) &#123;</span><br><span class="line">        buckets[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 求出元素在buckets中的位置 最后取余为了保证索引不会溢出</span></span><br><span class="line">        bucketIndex = <span class="built_in">Math</span>.floor(((arr[i] - min) / digit) % radixBase)</span><br><span class="line">        buckets[bucketIndex] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过现有值，求出累计值， 累计值就是，对应arr[i]在排序结果中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] += buckets[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再次遍历arr, 填充排序结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        bucketIndex = <span class="built_in">Math</span>.floor(((arr[i] - min) / digit) % radixBase)</span><br><span class="line">        <span class="comment">// 因为buckets中初始值为0 ，有值为1， 所以这里是--buckets[bucketIndex]</span></span><br><span class="line">        aux[--buckets[bucketIndex]] = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aux</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h3><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><ul>
<li>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。</li>
</ul>
<img src="/2021/11/04/学习JavaScript数据结构与算法/顺序搜索.png">

<h4 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequentialSearch</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ul>
<li>二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个1～100的数”的游戏。我们每回应一个数，那个人就会说这个数是高了、低了还是对了。</li>
<li>这个算法<strong>要求被搜索的数据结构已排序</strong>。</li>
<li>以下是该算法遵循的步骤。<ul>
<li>(1) 选择数组的中间值。</li>
<li>(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。</li>
<li>(3) 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找（较小）。</li>
<li>(4) 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找（较大）。</li>
</ul>
</li>
</ul>
<h4 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    quickSort(arr)</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>, high = arr.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high &amp;&amp; target) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内插-插值-搜索"><a href="#内插-插值-搜索" class="headerlink" title="内插(插值)搜索"></a>内插(插值)搜索</h3><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ul>
<li>内插搜索是改良版的二分搜索。二分搜索总是检查mid位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。</li>
<li>这个算法要求被搜索的数据结构已<strong>排序</strong>。</li>
<li>以下是该算法遵循的步骤：<ul>
<li>(1) 使用position公式选中一个值；</li>
<li>(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；</li>
<li>(3) 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找（较小）；</li>
<li>(4) 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找（较大）。</li>
</ul>
</li>
</ul>
<h4 id="代码实现-15"><a href="#代码实现-15" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际测试中， 数字差值小的情况下，结果正常， 数字差值大时， 结果存在问题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interpolationSearch</span>(<span class="params">arr, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span>  low = <span class="number">0</span>, high = arr.length<span class="number">-1</span>, delta = <span class="number">-1</span>, position = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high &amp;&amp; value &amp;&amp; value &gt;= arr[low] &amp;&amp; value &lt;= arr[high]) &#123;</span><br><span class="line">        delta = (value - arr[low]) / (arr[high] - value)</span><br><span class="line">        position = low + <span class="built_in">Math</span>.floor((high - low) * delta)</span><br><span class="line">        <span class="keyword">if</span> (arr[position] === value) &#123;</span><br><span class="line">            <span class="keyword">return</span> position</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; arr[position]) &#123;</span><br><span class="line">            low = position + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = position - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h3><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><ul>
<li>Fisher-Yates随机这个算法由Fisher和Yates创造，并由高德纳（Donald E. Knuth）在《计算机程序设计艺术》系列图书中推广。</li>
<li>它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差）</li>
</ul>
<h4 id="代码实现-16"><a href="#代码实现-16" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> randomIdx = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>))</span><br><span class="line">        [arr[randomIdx], arr[i]] = [arr[i], arr[randomIdx]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      

      
        
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//pan.baidu.com/share/qrcode?url=http://yoursite.com/2021/11/04/学习JavaScript数据结构与算法/" alt="微信分享二维码">
    </div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2022/01/29/JavaScript设计模式与开发实践/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          JavaScript设计模式与开发实践
        
      </div>
    </a>
  
  
    <a href="/2021/09/05/深入理解ES6/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">深入理解ES6</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
        <div class="toc-container tooltip-left">
            <i class="icon-font icon-category"></i>
            <div class="tooltip tooltip-east">
                <span class="tooltip-item">
                </span>
                <span class="tooltip-content">
                    <div class="toc-article">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一章-JavaScript简介"><span class="toc-number">1.</span> <span class="toc-text">第一章 JavaScript简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器环境搭建"><span class="toc-number">1.1.</span> <span class="toc-text">服务器环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础"><span class="toc-number">1.2.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#变量作用域"><span class="toc-number">1.2.1.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运算符"><span class="toc-number">1.2.2.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#真值和假值"><span class="toc-number">1.2.3.</span> <span class="toc-text">真值和假值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相等运算符-（-和-）"><span class="toc-number">1.2.4.</span> <span class="toc-text">相等运算符 （== 和 === ）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制结构"><span class="toc-number">1.3.</span> <span class="toc-text">控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数"><span class="toc-number">1.4.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript面向对象编程"><span class="toc-number">1.5.</span> <span class="toc-text">JavaScript面向对象编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试工具"><span class="toc-number">1.6.</span> <span class="toc-text">调试工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二章-ECMAScript和TypeScript概述"><span class="toc-number">2.</span> <span class="toc-text">第二章 ECMAScript和TypeScript概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ECMAScript还是JavaScript"><span class="toc-number">2.1.</span> <span class="toc-text">ECMAScript还是JavaScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6、ES2015、ES7、ES2016、ES8、ES2017和ES-Next"><span class="toc-number">2.2.</span> <span class="toc-text">ES6、ES2015、ES7、ES2016、ES8、ES2017和ES.Next</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Babel-js"><span class="toc-number">2.3.</span> <span class="toc-text">使用Babel.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECMAScript-2015-的功能"><span class="toc-number">2.4.</span> <span class="toc-text">ECMAScript 2015+的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用let替代var声明变量"><span class="toc-number">2.4.1.</span> <span class="toc-text">用let替代var声明变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板字面量"><span class="toc-number">2.4.2.</span> <span class="toc-text">模板字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#箭头函数"><span class="toc-number">2.4.3.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的参数默认值"><span class="toc-number">2.4.4.</span> <span class="toc-text">函数的参数默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#声明展开和剩余参数"><span class="toc-number">2.4.5.</span> <span class="toc-text">声明展开和剩余参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#增强的对象属性"><span class="toc-number">2.4.6.</span> <span class="toc-text">增强的对象属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用类进行面向对象编程"><span class="toc-number">2.4.7.</span> <span class="toc-text">使用类进行面向对象编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#乘方运算符"><span class="toc-number">2.4.8.</span> <span class="toc-text">乘方运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模块"><span class="toc-number">2.4.9.</span> <span class="toc-text">模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍TypeScript"><span class="toc-number">2.5.</span> <span class="toc-text">介绍TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类型推断"><span class="toc-number">2.5.1.</span> <span class="toc-text">类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口"><span class="toc-number">2.5.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他TypeScript功能"><span class="toc-number">2.5.3.</span> <span class="toc-text">其他TypeScript功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript中对JavaScript文件的编译时检查"><span class="toc-number">2.5.4.</span> <span class="toc-text">TypeScript中对JavaScript文件的编译时检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三章-数组"><span class="toc-number">3.</span> <span class="toc-text">第三章 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么用数组"><span class="toc-number">3.1.</span> <span class="toc-text">为什么用数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建和初始化数组"><span class="toc-number">3.2.</span> <span class="toc-text">创建和初始化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加元素"><span class="toc-number">3.3.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除元素"><span class="toc-number">3.4.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在任意位置添加或删除元素"><span class="toc-number">3.5.</span> <span class="toc-text">在任意位置添加或删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维和多维数组"><span class="toc-number">3.6.</span> <span class="toc-text">二维和多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript的数组方法参考"><span class="toc-number">3.7.</span> <span class="toc-text">JavaScript的数组方法参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型数组"><span class="toc-number">3.8.</span> <span class="toc-text">类型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第四章-栈"><span class="toc-number">4.</span> <span class="toc-text">第四章 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建基于数组的栈"><span class="toc-number">4.1.</span> <span class="toc-text">创建基于数组的栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建基于JavaScript对象的Stack类"><span class="toc-number">4.2.</span> <span class="toc-text">创建基于JavaScript对象的Stack类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保护数据结构内部元素（私有属性）"><span class="toc-number">4.3.</span> <span class="toc-text">保护数据结构内部元素（私有属性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用栈解决问题"><span class="toc-number">4.4.</span> <span class="toc-text">用栈解决问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五章-队列和双端队列"><span class="toc-number">5.</span> <span class="toc-text">第五章 队列和双端队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于对象创建队列"><span class="toc-number">5.1.</span> <span class="toc-text">基于对象创建队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双端队列"><span class="toc-number">5.2.</span> <span class="toc-text">双端队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用队列和双端队列解决问题"><span class="toc-number">5.3.</span> <span class="toc-text">使用队列和双端队列解决问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#循环队列–击鼓传花游戏"><span class="toc-number">5.3.1.</span> <span class="toc-text">循环队列–击鼓传花游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回文检查器"><span class="toc-number">5.3.2.</span> <span class="toc-text">回文检查器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript任务队列"><span class="toc-number">5.3.3.</span> <span class="toc-text">JavaScript任务队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第六章-链表"><span class="toc-number">6.</span> <span class="toc-text">第六章 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链表数据结构"><span class="toc-number">6.1.</span> <span class="toc-text">链表数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双向链表"><span class="toc-number">6.2.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环链表"><span class="toc-number">6.3.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序链表"><span class="toc-number">6.4.</span> <span class="toc-text">有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建StackLinkedList类"><span class="toc-number">6.5.</span> <span class="toc-text">创建StackLinkedList类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第七章-集合"><span class="toc-number">7.</span> <span class="toc-text">第七章 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建集合类"><span class="toc-number">7.1.</span> <span class="toc-text">创建集合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合运算"><span class="toc-number">7.2.</span> <span class="toc-text">集合运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#并集"><span class="toc-number">7.2.1.</span> <span class="toc-text">并集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#交集"><span class="toc-number">7.2.2.</span> <span class="toc-text">交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#差集"><span class="toc-number">7.2.3.</span> <span class="toc-text">差集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#子集"><span class="toc-number">7.2.4.</span> <span class="toc-text">子集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECMAScript2015中的Set类"><span class="toc-number">7.3.</span> <span class="toc-text">ECMAScript2015中的Set类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第八章-字典和散列表-哈希表"><span class="toc-number">8.</span> <span class="toc-text">第八章 字典和散列表(哈希表)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字典"><span class="toc-number">8.1.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#散列表-哈希表"><span class="toc-number">8.2.</span> <span class="toc-text">散列表(哈希表)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#散列表的理解"><span class="toc-number">8.2.1.</span> <span class="toc-text">散列表的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何定义key"><span class="toc-number">8.2.2.</span> <span class="toc-text">如何定义key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希化-哈希函数-哈希表的关系"><span class="toc-number">8.2.3.</span> <span class="toc-text">哈希化 哈希函数 哈希表的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希表的常见构造方法："><span class="toc-number">8.2.4.</span> <span class="toc-text">哈希表的常见构造方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决哈希表冲突的方法"><span class="toc-number">8.2.5.</span> <span class="toc-text">解决哈希表冲突的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希化的效率"><span class="toc-number">8.2.6.</span> <span class="toc-text">哈希化的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希表的长度"><span class="toc-number">8.2.7.</span> <span class="toc-text">哈希表的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单构建哈希表"><span class="toc-number">8.2.8.</span> <span class="toc-text">简单构建哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#散列集合"><span class="toc-number">8.2.9.</span> <span class="toc-text">散列集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理冲突方法实现-链地址法"><span class="toc-number">8.2.10.</span> <span class="toc-text">处理冲突方法实现-链地址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理冲突方法实现-线性探测"><span class="toc-number">8.2.11.</span> <span class="toc-text">处理冲突方法实现-线性探测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更好的哈希函数-djb2"><span class="toc-number">8.2.12.</span> <span class="toc-text">更好的哈希函数- djb2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6中的-Map-WeakSet-WeakMap"><span class="toc-number">8.3.</span> <span class="toc-text">ES6中的 Map , WeakSet, WeakMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第九章-递归"><span class="toc-number">9.</span> <span class="toc-text">第九章 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是递归"><span class="toc-number">9.1.</span> <span class="toc-text">什么是递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算一个数的阶乘"><span class="toc-number">9.2.</span> <span class="toc-text">计算一个数的阶乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#斐波那契数列"><span class="toc-number">9.3.</span> <span class="toc-text">斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代求斐波那契数"><span class="toc-number">9.3.1.</span> <span class="toc-text">迭代求斐波那契数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归求斐波那契数"><span class="toc-number">9.3.2.</span> <span class="toc-text">递归求斐波那契数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#记忆化斐波那契数"><span class="toc-number">9.3.3.</span> <span class="toc-text">记忆化斐波那契数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要用递归"><span class="toc-number">9.3.4.</span> <span class="toc-text">为什么要用递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十章-树"><span class="toc-number">10.</span> <span class="toc-text">第十章 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#树的相关名词"><span class="toc-number">10.1.</span> <span class="toc-text">树的相关名词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的种类："><span class="toc-number">10.2.</span> <span class="toc-text">树的种类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉搜索树（Binary-Search-Tree）"><span class="toc-number">10.3.</span> <span class="toc-text">二叉搜索树（Binary Search Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL树（Adelson-Velskii-Land）"><span class="toc-number">10.4.</span> <span class="toc-text">AVL树（Adelson-Velskii-Land）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念"><span class="toc-number">10.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高度和平衡因子"><span class="toc-number">10.4.2.</span> <span class="toc-text">高度和平衡因子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现"><span class="toc-number">10.4.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树"><span class="toc-number">10.5.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优点"><span class="toc-number">10.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#红黑树的规则"><span class="toc-number">10.5.2.</span> <span class="toc-text">红黑树的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#节点的插入"><span class="toc-number">10.5.3.</span> <span class="toc-text">节点的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#节点插入时的几种情况"><span class="toc-number">10.5.4.</span> <span class="toc-text">节点插入时的几种情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#案例演示"><span class="toc-number">10.5.5.</span> <span class="toc-text">案例演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-1"><span class="toc-number">10.5.6.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十一章-二叉堆和堆排序"><span class="toc-number">11.</span> <span class="toc-text">第十一章 二叉堆和堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉堆数据结构"><span class="toc-number">11.1.</span> <span class="toc-text">二叉堆数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序"><span class="toc-number">11.2.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十二章-图"><span class="toc-number">12.</span> <span class="toc-text">第十二章 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图的相关术语"><span class="toc-number">12.1.</span> <span class="toc-text">图的相关术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图的表示"><span class="toc-number">12.2.</span> <span class="toc-text">图的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#邻接矩阵"><span class="toc-number">12.2.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#邻接表"><span class="toc-number">12.2.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关联矩阵"><span class="toc-number">12.2.3.</span> <span class="toc-text">关联矩阵</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建Graph-类"><span class="toc-number">12.3.</span> <span class="toc-text">创建Graph 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图的遍历"><span class="toc-number">12.4.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#广度优先搜索"><span class="toc-number">12.4.1.</span> <span class="toc-text">广度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#代码实现-2"><span class="toc-number">12.4.1.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BFS的实际应用-（使用BEF寻找最短路径）"><span class="toc-number">12.4.1.2.</span> <span class="toc-text">BFS的实际应用 （使用BEF寻找最短路径）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#深度优先搜索"><span class="toc-number">12.4.2.</span> <span class="toc-text">深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#代码实现-3"><span class="toc-number">12.4.2.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS算法改造"><span class="toc-number">12.4.2.2.</span> <span class="toc-text">DFS算法改造</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS改造后的实际应用-（实现拓扑排序）"><span class="toc-number">12.4.2.3.</span> <span class="toc-text">DFS改造后的实际应用 （实现拓扑排序）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短路径算法"><span class="toc-number">12.5.</span> <span class="toc-text">最短路径算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra（狄克斯特拉）算法"><span class="toc-number">12.5.1.</span> <span class="toc-text">Dijkstra（狄克斯特拉）算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd-Warshall-弗洛伊德-算法"><span class="toc-number">12.5.2.</span> <span class="toc-text">Floyd-Warshall(弗洛伊德)算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小生成树"><span class="toc-number">12.6.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim-普里姆-算法"><span class="toc-number">12.6.1.</span> <span class="toc-text">Prim(普里姆)算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal-克鲁斯卡尔-算法"><span class="toc-number">12.6.2.</span> <span class="toc-text">Kruskal(克鲁斯卡尔)算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十三章-排序和搜索算法"><span class="toc-number">13.</span> <span class="toc-text">第十三章 排序和搜索算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序"><span class="toc-number">13.1.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路"><span class="toc-number">13.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-4"><span class="toc-number">13.1.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度的计算"><span class="toc-number">13.1.3.</span> <span class="toc-text">时间复杂度的计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序"><span class="toc-number">13.2.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-1"><span class="toc-number">13.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-5"><span class="toc-number">13.2.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择排序的效率"><span class="toc-number">13.2.3.</span> <span class="toc-text">选择排序的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择排序与冒泡排序的区别"><span class="toc-number">13.2.4.</span> <span class="toc-text">选择排序与冒泡排序的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序"><span class="toc-number">13.3.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-2"><span class="toc-number">13.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-6"><span class="toc-number">13.3.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入排序的效率"><span class="toc-number">13.3.3.</span> <span class="toc-text">插入排序的效率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归并排序"><span class="toc-number">13.4.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-3"><span class="toc-number">13.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-7"><span class="toc-number">13.4.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序"><span class="toc-number">13.5.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-4"><span class="toc-number">13.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-8"><span class="toc-number">13.5.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#希尔排序的效率"><span class="toc-number">13.5.3.</span> <span class="toc-text">希尔排序的效率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序"><span class="toc-number">13.6.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-5"><span class="toc-number">13.6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-9"><span class="toc-number">13.6.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计数排序"><span class="toc-number">13.7.</span> <span class="toc-text">计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-6"><span class="toc-number">13.7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-10"><span class="toc-number">13.7.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桶排序"><span class="toc-number">13.8.</span> <span class="toc-text">桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-7"><span class="toc-number">13.8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-11"><span class="toc-number">13.8.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基数排序"><span class="toc-number">13.9.</span> <span class="toc-text">基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-8"><span class="toc-number">13.9.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-12"><span class="toc-number">13.9.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序搜索"><span class="toc-number">13.10.</span> <span class="toc-text">顺序搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-9"><span class="toc-number">13.10.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-13"><span class="toc-number">13.10.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二分搜索"><span class="toc-number">13.11.</span> <span class="toc-text">二分搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-10"><span class="toc-number">13.11.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-14"><span class="toc-number">13.11.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内插-插值-搜索"><span class="toc-number">13.12.</span> <span class="toc-text">内插(插值)搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-11"><span class="toc-number">13.12.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-15"><span class="toc-number">13.12.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机算法"><span class="toc-number">13.13.</span> <span class="toc-text">随机算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-12"><span class="toc-number">13.13.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-16"><span class="toc-number">13.13.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li></ol>
                    </div>
                </span>
            </div>
        </div>
        
    </div>
</aside>



  
  
  

  

  

  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2022 Mu
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 50%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
        
      
      <li style="width: 50%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">angular</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Ajax</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Fetch</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">css</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">博客 个人博客 搭建过程 教程</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">强制类型转换</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">JavaScript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Vue-router 路由 前端路由</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Sass</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">ts</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">VueCLI 脚手架 VueCLI2</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">axios 异步请求 Promise特性 请求响应数据</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">git github</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">VueCLI 脚手架 VueCLI3</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">jQuery javaScript框架 教程</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Vuex 状态管理工具</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">node</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">webpack 打包工具 模块化</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">vuex 状态管理工具</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">垃圾回收</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">跨域</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">对象</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">异步</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">浏览器</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">微任务 宏任务</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">存储技术</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">网络攻击</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Vue</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">天津师范大学20级应届毕业生，对于前端所必须的各项技能均有一定的了解</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>